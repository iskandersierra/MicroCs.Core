using MicroCs.Generators.Aop;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace MicroCs.Generators;

internal static partial class GeneratorUtils
{
    public const string MainNamespace = "MicroCs.Generators";

    public static string ToParameterName(this string name) =>
        name.Substring(0, 1).ToLowerInvariant() + name.Substring(1);

    #region [ Syntax ]

    public static SyntaxTriviaList CreateAutoGeneratedHeaders()
    {
        return TriviaList(
            Comment("// <auto-generated />"),
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)));
    }

    #region [ Attributes ]

    public static IEnumerable<AttributeSyntax> GetAttributes(
        this MemberDeclarationSyntax syntax) =>
        syntax.AttributeLists
            .SelectMany(list => list.Attributes);

    public static bool HasAttribute(
        this IEnumerable<AttributeSyntax> attributes,
        string attributeTypeFullName,
        SemanticModel semanticModel,
        SymbolDisplayFormat? format = null) =>
        attributes
            .Any(attributeSyntax =>
            {
                var symbolInfo = ModelExtensions.GetSymbolInfo(semanticModel, attributeSyntax);

                if (symbolInfo.Symbol is not IMethodSymbol attrCtorSymbol)
                    return false;

                if (attrCtorSymbol.ContainingType
                    is not { } attrTypeSymbol)
                    return false;

                var attrFullName = attrTypeSymbol.ToDisplayString(format);

                return string.Equals(attrFullName, attributeTypeFullName, StringComparison.Ordinal);
            });

    public static bool HasAttribute(
        this MemberDeclarationSyntax syntax,
        string attributeTypeFullName,
        SemanticModel semanticModel,
        SymbolDisplayFormat? format = null) =>
        syntax.GetAttributes().HasAttribute(attributeTypeFullName, semanticModel, format);

    #endregion [ Attributes ]

    #endregion [ Syntax ]

    #region [ Semantics ]

    #region [ Attributes ]

    public static bool HasAttribute(
        this ISymbol symbol,
        string attributeTypeFullName,
        SymbolDisplayFormat? format = null) =>
        symbol.GetAttributes()
            .Select(a => a.AttributeClass?.ToDisplayString(format))
            .Where(e => e is not null)
            .Any(e => string.Equals(e, attributeTypeFullName, StringComparison.Ordinal));

    public static IReadOnlyList<AttributeModel> ExtractAttributes(
        this ISymbol symbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        return GetAttributes().ToArray();

        IEnumerable<AttributeModel> GetAttributes()
        {
            foreach (var attributeData in symbol.GetAttributes())
            {
                var type = attributeData.AttributeClass?.ToNamedTypeModel();

                if (type is null)
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.UnexpectedTypeOnSymbol,
                            symbol.Locations[0],
                            symbol.ToDisplayString()));

                    continue;
                }

                var attributeModel = new AttributeModel
                {
                    Data = attributeData,
                    Type = type,

                };

                yield return attributeModel;
            }
        }
    }

    #endregion [ Attributes ]

    #region [ Types ]

    public static TypeModel ToNamedTypeModel(
        this INamedTypeSymbol symbol)
    {
        return new TypeModel
        {
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            FullName = symbol.ToDisplayString(),
            Name = symbol.Name,
            Symbol = symbol,
        };
    }

    public static TypeModel? ToNamedTypeModel(
        this IArrayTypeSymbol symbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        var elementType = symbol.ElementType.ToNamedTypeModel(context, compilation);

        if (elementType is null) return null;

        return new TypeModel
        {
            Namespace = null,
            FullName = symbol.ToDisplayString(),
            Name = symbol.Name,
            Symbol = symbol,
        };
    }

    public static TypeModel? ToNamedTypeModel(
        this ITypeSymbol symbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        switch (symbol)
        {
            case INamedTypeSymbol namedTypeSymbol:
                return namedTypeSymbol.ToNamedTypeModel();

            case IArrayTypeSymbol arrayTypeSymbol:
                return arrayTypeSymbol.ToNamedTypeModel(context, compilation);

            default:
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.UnexpectedTypeOnSymbol,
                            symbol.Locations[0],
                            symbol.ToDisplayString()));

                    return null;
                }
        }
    }


    public static TypeWithMembersModel? ExtractTypeWithMembersModel(
        this INamedTypeSymbol type,
        SourceProductionContext context,
        Compilation compilation)
    {
        var methods = type.ExtractMethods(context, compilation);
        var attributes = type.ExtractAttributes(context, compilation);

        return new TypeWithMembersModel()
        {
            Namespace = type.ContainingNamespace?.ToDisplayString(),
            FullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            Name = type.Name,
            Methods = methods,
            Attributes = attributes,
            Symbol = type,
        };
    }


    public const string TaskFullName = "System.Threading.Tasks.Task";
    public const string ValueTaskFullName = "System.Threading.Tasks.ValueTask";
    public const string Task1FullName = "System.Threading.Tasks.Task<>";
    public const string Value1TaskFullName = "System.Threading.Tasks.ValueTask<>";

    public static AsyncTypeInfo GetAsyncInfo(
        this ITypeSymbol typeSymbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        var result = new AsyncTypeInfo();

        if (typeSymbol is not INamedTypeSymbol namedTypeSymbol)
            return result;

        var typeFullName = namedTypeSymbol.ToDisplayString();

        if (string.Equals(typeFullName, TaskFullName, StringComparison.Ordinal) ||
            string.Equals(typeFullName, ValueTaskFullName, StringComparison.Ordinal))
        {
            result.IsAsync = true;
            result.InnerType = TypeModel.Void;
        }
        else if (namedTypeSymbol is {IsGenericType: true, TypeArguments.Length: 1} &&
                 namedTypeSymbol.ConstructUnboundGenericType() is {} genericType &&
                 genericType.ToDisplayString() is { } genericTypeFullName &&
                 (string.Equals(genericTypeFullName, Task1FullName, StringComparison.Ordinal) ||
                  string.Equals(genericTypeFullName, Value1TaskFullName, StringComparison.Ordinal)))
        {
            result.IsAsync = true;
            result.InnerType = namedTypeSymbol.TypeArguments[0].ToNamedTypeModel(context, compilation);
        }

        return result;
    }

    #endregion [ Types ]

    #region [ Members ]

    public static MethodModel? ToMethodModel(
        this IMethodSymbol methodSymbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        var parameters = methodSymbol.Parameters
            .Select(parameterSymbol =>
            {
                var typeModel = parameterSymbol.Type
                    .ToNamedTypeModel(context, compilation);

                if (typeModel is null) return null;

                var attributes = parameterSymbol.ExtractAttributes(context, compilation);

                return new MethodParameterModel
                {
                    Name = parameterSymbol.Name,
                    Type = typeModel,
                    Attributes = attributes,
                    Symbol = parameterSymbol,
                };
            })
            .Where(p => p is not null)
            .Select(p => p!)
            .ToList();

        var returnType = methodSymbol.ReturnType.ToNamedTypeModel(context, compilation);

        if (returnType is null || parameters.Count != methodSymbol.Parameters.Length)
            return null;

        var attributes = methodSymbol.ExtractAttributes(context, compilation);
        
        return new MethodModel
        {
            Name = methodSymbol.Name,
            Parameters = parameters,
            ReturnType = returnType,
            Attributes = attributes,
            Symbol = methodSymbol,
        };
    }

    public static IReadOnlyList<MethodModel> ExtractMethods(
        this INamedTypeSymbol symbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        var result = symbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Select(m => m.ToMethodModel(context, compilation))
            .Where(m => m is not null)
            .Select(m => m!)
            .ToList();

        return result;
    }

    #endregion [ Members ]

    #endregion [ Semantics ]
}
