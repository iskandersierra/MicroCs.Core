using MicroCs.Generators.Aop;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace MicroCs.Generators;

internal static partial class GeneratorUtils
{
    public const string MainNamespace = "MicroCs.Generators";

    public static string ToParameterName(this string name) =>
        name.Substring(0, 1).ToLowerInvariant() + name.Substring(1);

    #region [ Syntax ]

    public static SyntaxTriviaList CreateAutoGeneratedHeaders()
    {
        return TriviaList(
            Comment("// <auto-generated />"),
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)));
    }

    #region [ Attributes ]

    public static IEnumerable<AttributeSyntax> GetAttributes(
        this MemberDeclarationSyntax syntax) =>
        syntax.AttributeLists
            .SelectMany(list => list.Attributes);

    public static bool HasAttribute(
        this IEnumerable<AttributeSyntax> attributes,
        string attributeTypeFullName,
        SemanticModel semanticModel,
        SymbolDisplayFormat? format = null) =>
        attributes
            .Any(attributeSyntax =>
            {
                var symbolInfo = ModelExtensions.GetSymbolInfo(semanticModel, attributeSyntax);

                if (symbolInfo.Symbol is not IMethodSymbol attrCtorSymbol)
                    return false;

                if (attrCtorSymbol.ContainingType
                    is not { } attrTypeSymbol)
                    return false;

                var attrFullName = attrTypeSymbol.ToDisplayString(format);

                return string.Equals(attrFullName, attributeTypeFullName, StringComparison.Ordinal);
            });

    public static bool HasAttribute(
        this MemberDeclarationSyntax syntax,
        string attributeTypeFullName,
        SemanticModel semanticModel,
        SymbolDisplayFormat? format = null) =>
        syntax.GetAttributes().HasAttribute(attributeTypeFullName, semanticModel, format);

    #endregion [ Attributes ]

    public static ExpressionSyntax CreateBinaryExpression(
        SyntaxKind syntaxKind,
        params ExpressionSyntax[] expressions)
    {
        if (expressions.Length == 0)
            throw new ArgumentException("Value cannot be an empty collection.", nameof(expressions));

        if (expressions.Length == 1) return expressions[0];

        var result = expressions[0];

        for (var i = 1; i < expressions.Length; i++)
        {
            result = BinaryExpression(syntaxKind, result, expressions[i]);
        }

        return result;
    }

    #endregion [ Syntax ]

    #region [ Semantics ]

    #region [ Attributes ]

    public static bool HasAttribute(
        this ISymbol symbol,
        string attributeTypeFullName,
        SymbolDisplayFormat? format = null) =>
        symbol.GetAttributes()
            .Select(a => a.AttributeClass?.ToDisplayString(format))
            .Where(e => e is not null)
            .Any(e => string.Equals(e, attributeTypeFullName, StringComparison.Ordinal));

    public static IReadOnlyList<AttributeModel> ExtractAttributes(
        this ISymbol symbol,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        return GetAttributes().ToArray();

        IEnumerable<AttributeModel> GetAttributes()
        {
            foreach (var attributeData in symbol.GetAttributes())
            {
                var type = attributeData.AttributeClass?.ToTypeModel(context, compilation, location);

                if (type is null)
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.UnexpectedTypeOnSymbol,
                            symbol.Locations.FirstOrDefault() ?? location,
                            symbol.ToDisplayString()));

                    continue;
                }

                var attributeModel = new AttributeModel
                {
                    Data = attributeData,
                    Type = type,

                };

                yield return attributeModel;
            }
        }
    }

    #endregion [ Attributes ]

    #region [ Types ]

    public static string? GetNamespace(
        this INamespaceSymbol symbol)
    {
        return symbol.IsGlobalNamespace ? null : symbol.ToDisplayString();
    }

    public static TypeModel? ToTypeModel(
        this ITypeSymbol symbol,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        switch (symbol)
        {
            case INamedTypeSymbol namedTypeSymbol:
            {
                return new TypeModel
                {
                    Namespace = namedTypeSymbol.ContainingNamespace.GetNamespace(),
                    FullName = namedTypeSymbol.ToDisplayString(),
                    Name = namedTypeSymbol.Name,
                    Symbol = namedTypeSymbol,
                };
            }

            case IArrayTypeSymbol arrayTypeSymbol:
            {
                var elementType = arrayTypeSymbol.ElementType.ToTypeModel(context, compilation, location);

                if (elementType is null) return null;

                return new TypeModel
                {
                    Namespace = null,
                    FullName = arrayTypeSymbol.ToDisplayString(),
                    Name = arrayTypeSymbol.Name,
                    Symbol = arrayTypeSymbol,
                };
            }

            default:
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.UnexpectedTypeOnSymbol,
                            symbol.Locations.FirstOrDefault() ?? location,
                            symbol.ToDisplayString()));

                    return null;
                }
        }
    }


    public static TypeWithMembersModel? ExtractTypeWithMembersModel(
        this INamedTypeSymbol type,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var methods = type.ExtractMethods(context, compilation, location);
        var attributes = type.ExtractAttributes(context, compilation, location);

        return new TypeWithMembersModel()
        {
            Namespace = type.ContainingNamespace.GetNamespace(),
            FullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            Name = type.Name,
            Methods = methods,
            Attributes = attributes,
            Symbol = type,
        };
    }


    public const string TaskFullName = "System.Threading.Tasks.Task";
    public const string ValueTaskFullName = "System.Threading.Tasks.ValueTask";
    public const string Task1FullName = "System.Threading.Tasks.Task<>";
    public const string Value1TaskFullName = "System.Threading.Tasks.ValueTask<>";

    public static AsyncTypeInfo GetAsyncInfo(
        this ITypeSymbol typeSymbol,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var result = new AsyncTypeInfo();

        if (typeSymbol is not INamedTypeSymbol namedTypeSymbol)
            return result;

        var typeFullName = namedTypeSymbol.ToDisplayString();

        if (string.Equals(typeFullName, TaskFullName, StringComparison.Ordinal) ||
            string.Equals(typeFullName, ValueTaskFullName, StringComparison.Ordinal))
        {
            result.IsAsync = true;
            result.InnerType = TypeModel.Void;
        }
        else if (namedTypeSymbol is {IsGenericType: true, TypeArguments.Length: 1} &&
                 namedTypeSymbol.ConstructUnboundGenericType() is {} genericType &&
                 genericType.ToDisplayString() is { } genericTypeFullName &&
                 (string.Equals(genericTypeFullName, Task1FullName, StringComparison.Ordinal) ||
                  string.Equals(genericTypeFullName, Value1TaskFullName, StringComparison.Ordinal)))
        {
            result.IsAsync = true;
            result.InnerType = namedTypeSymbol.TypeArguments[0].ToTypeModel(context, compilation, location);
        }

        return result;
    }

    #endregion [ Types ]

    #region [ Members ]

    public static MethodModel? ToMethodModel(
        this IMethodSymbol methodSymbol,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var parameters = methodSymbol.Parameters
            .Select(parameterSymbol =>
            {
                var typeModel = parameterSymbol.Type
                    .ToTypeModel(context, compilation, location);

                if (typeModel is null) return null;

                var attributes = parameterSymbol
                    .ExtractAttributes(context, compilation, location);

                return new MethodParameterModel
                {
                    Name = parameterSymbol.Name,
                    Type = typeModel,
                    Attributes = attributes,
                    Symbol = parameterSymbol,
                };
            })
            .Where(p => p is not null)
            .Select(p => p!)
            .ToList();

        var returnType = methodSymbol.ReturnType
            .ToTypeModel(context, compilation, location);

        if (returnType is null || parameters.Count != methodSymbol.Parameters.Length)
            return null;

        var attributes = methodSymbol
            .ExtractAttributes(context, compilation, location);
        
        return new MethodModel
        {
            Name = methodSymbol.Name,
            Parameters = parameters,
            ReturnType = returnType,
            Attributes = attributes,
            Symbol = methodSymbol,
        };
    }

    public static IReadOnlyList<MethodModel> ExtractMethods(
        this INamedTypeSymbol symbol,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var result = symbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Select(m => m.ToMethodModel(context, compilation, location))
            .Where(m => m is not null)
            .Select(m => m!)
            .ToList();

        return result;
    }

    #endregion [ Members ]

    #endregion [ Semantics ]
}
