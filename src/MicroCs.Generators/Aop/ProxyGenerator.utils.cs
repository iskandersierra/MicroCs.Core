using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using System.Collections.Immutable;
using System.Reflection;
using System.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace MicroCs.Generators.Aop;

internal static class ProxyGeneratorUtils
{
    #region [ Attributes Full Names ]

    private const string GenerateProxyAttributeFullName =
        $"{AopGeneratorUtils.MainNamespace}.GenerateProxyAttribute";

    private const string InterceptorAttributeFullName =
        $"{AopGeneratorUtils.MainNamespace}.InterceptorAttribute";

    #endregion [ Attributes Full Names ]

    #region [ RegisterProxyAttributes ]

    public static void RegisterProxyAttributes(
        this IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(AddAttributesSource);

    private static void AddAttributesSource(
        IncrementalGeneratorPostInitializationContext context)
    {
        var model = new ProxyGeneratorAttributesModel
        {
            Namespace = AopGeneratorUtils.MainNamespace,
        };

        var fileName = "ProxyGeneratorAttributes.g.cs";
        var tree = GenerateProxyAttributes(model);
        var source = tree.GetText(Encoding.UTF8);
        context.AddSource(fileName, source);
    }

    private static CompilationUnitSyntax GenerateProxyAttributes(ProxyGeneratorAttributesModel model)
    {
        CompilationUnitSyntax unitSyntax =
            CompilationUnit()
                .WithMembers(SingletonList<MemberDeclarationSyntax>(
                    FileScopedNamespaceDeclaration(ParseName(model.Namespace))
                        .WithNamespaceKeyword(Token(
                            GeneratorUtils.CreateAutoGeneratedHeaders(),
                            SyntaxKind.NamespaceKeyword,
                            TriviaList()))
                        .WithMembers(List<MemberDeclarationSyntax>(
                            new[]
                            {
                                CreateAttribute("GenerateProxy", AttributeTargets.Class),
                                CreateAttribute("Interceptor", AttributeTargets.Field),
                            }))))
                .NormalizeWhitespace();

        return unitSyntax;

        MemberDeclarationSyntax CreateAttribute(
            string name,
            AttributeTargets targets)
        {
            // System.AttributeTargets.Class | System.AttributeTargets.Field | ...
            var targetsExpression = GeneratorUtils.CreateBinaryExpression(
                SyntaxKind.BitwiseOrExpression,
                Enum.GetValues(typeof(AttributeTargets))
                    .OfType<AttributeTargets>()
                    .Where(value => value != AttributeTargets.All && (targets & value) == value)
                    .Select(value => ParseExpression($"{typeof(AttributeTargets).FullName}.{value}"))
                    .ToArray()
                );

            // [System.AttributeUsage($Targets)]
            var attributeUsage =
                Attribute(IdentifierName("System.AttributeUsageAttribute"))
                    .WithArgumentList(AttributeArgumentList(SingletonSeparatedList(
                        AttributeArgument(targetsExpression))));

            return ClassDeclaration($"{name}Attribute")
                .WithAttributeLists(SingletonList(
                    AttributeList(SingletonSeparatedList(attributeUsage))))
                .WithModifiers(TokenList(
                    Token(SyntaxKind.InternalKeyword),
                    Token(SyntaxKind.SealedKeyword)))
                .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(
                    SimpleBaseType(ParseTypeName(typeof(Attribute).FullName!)))));
        }
    }

    #endregion [ RegisterProxyAttributes ]

    #region [ RegisterProxyClasses ]

    public static void RegisterProxyClasses(
        this IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                PartialClassWithBaseTypesAndAttributes,
                HasGenerateProxyAttribute)
            .Where(e => e is not null)
            .Select((e, _) => e!);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(classes.Collect()),
            GenerateProxyClasses);
    }

    private static bool PartialClassWithBaseTypesAndAttributes(
        SyntaxNode node,
        CancellationToken cancel)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } @class &&
               @class.Modifiers.Any(SyntaxKind.PartialKeyword) &&
               !@class.Modifiers.Any(SyntaxKind.StaticKeyword);
            // && @class.BaseList?.Types is { Count: > 0 };
    }

    private static ClassDeclarationSyntax? HasGenerateProxyAttribute(
        GeneratorSyntaxContext context,
        CancellationToken cancel)
    {
        if (context.Node is not ClassDeclarationSyntax @class) return null;

        var hasGenerateProxyAttribute = @class
            .HasAttribute(GenerateProxyAttributeFullName, context.SemanticModel);

        return hasGenerateProxyAttribute ? @class : null;
    }

    private static void GenerateProxyClasses(
        SourceProductionContext context,
        (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes) data)
    {
        var models = data.classes
            .ExtractClassModels(context, data.compilation);

        for (int i = 0; i < models.Count; i++)
        {
            var model = models[i];
            if (!model.ShouldGenerateCode) continue;
            var fileName = $"{model.Name}.{i}.g.cs";
            var tree = GenerateProxyClass(model);
            var source = tree.GetText(Encoding.UTF8);
            context.AddSource(fileName, source);
        }
    }

    #region [ Extract ]

    private static IReadOnlyList<ProxyGeneratorClassModel> ExtractClassModels(
        this ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context,
        Compilation compilation)
    {
        return classes
            .Select(classSyntax => classSyntax
                .ExtractGeneratorClassModel(context, compilation))
            .Where(model => model is not null)
            .Select(model => model!)
            .ToArray();
    }

    private static ProxyGeneratorClassModel? ExtractGeneratorClassModel(
        this ClassDeclarationSyntax classSyntax,
        SourceProductionContext context,
        Compilation compilation)
    {
        var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);

        if (semanticModel.GetDeclaredSymbol(classSyntax) is not { } classSymbol)
            return null;

        var className = classSymbol.Name;
        var @namespace = classSymbol.ContainingNamespace.GetNamespace();

        var interfaces = classSymbol.AllInterfaces
            .Select(interfaceSymbol => interfaceSymbol
                .ExtractProxyInterfaceModel(
                    context,
                    compilation,
                    interfaceSymbol.Locations.FirstOrDefault() ?? classSyntax.GetLocation()))
            .Where(model => model is not null)
            .Select(model => model!)
            .ToArray();

        if (interfaces.Length == 0)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasNoInterfaces,
                    classSyntax.GetLocation(),
                    className));
            return null;
        }

        var interceptor = classSymbol
            .ExtractInterceptorModel(context, compilation, classSyntax.GetLocation());

        if (interceptor is null) return null;

        var resultModel = new ProxyGeneratorClassModel
        {
            Namespace = @namespace,
            Name = className,
            Interfaces = interfaces,
            Interceptor = interceptor,
        };

        foreach (var @interface in interfaces)
        {
            @interface.DeclaringClass = resultModel;
        }

        interceptor.DeclaringClass = resultModel;

        return resultModel;
    }

    private static ProxyGeneratorInterfaceModel? ExtractProxyInterfaceModel(
        this INamedTypeSymbol typeSymbol,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var type = typeSymbol
            .ExtractTypeWithMembersModel(context, compilation, location);

        if (type is null) return null;

        var methods = type.Methods
            .Select((method, index) =>
            {
                var asyncInfo = method.ReturnType.Symbol
                    .GetAsyncInfo(context, compilation, location);

                return new ProxyGeneratorInterfaceMethodModel
                {
                    Method = method,
                    Index = index,
                    IsAsync = asyncInfo.IsAsync,
                    ResultType = asyncInfo.InnerType ?? method.ReturnType,
                };
            })
            .ToArray();

        var resultModel = new ProxyGeneratorInterfaceModel
        {
            ParameterName = typeSymbol.Name.ToParameterName(),
            Type = type,
            Methods = methods,
        };

        foreach (var method in methods)
        {
            method.DeclaringInterface = resultModel;
        }

        return resultModel;
    }

    private static ProxyGeneratorInterceptorModel? ExtractInterceptorModel(
        this INamedTypeSymbol classSymbol,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        if (!ExtractInterceptorField(
                classSymbol,
                context,
                location,
                out var interceptorField))
            return null;

        if (interceptorField!.Type is not INamedTypeSymbol interceptorTypeSymbol)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyInterceptorIsNotNamedType,
                    interceptorField.Locations.FirstOrDefault() ?? location,
                    interceptorField.Name,
                    interceptorField.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)));

            return null;
        }

        var interceptorType = interceptorTypeSymbol
            .ExtractTypeWithMembersModel(context, compilation, location);

        if (interceptorType is null) return null;

        var beforeCall = interceptorType.ExtractBeforeCall(context, compilation, location);
        var afterCall = interceptorType.ExtractAfterCall(context, compilation, location);
        var afterSuccessCall = interceptorType.ExtractAfterSuccessCall(context, compilation, location);
        var afterFailureCall = interceptorType.ExtractAfterFailureCall(context, compilation, location);

        return new ProxyGeneratorInterceptorModel
        {
            ParameterName = interceptorField.Name.ToParameterName(),
            Type = interceptorType,
            BeforeCall = beforeCall,
            AfterCall = afterCall,
            AfterSuccessCall = afterSuccessCall,
            AfterFailureCall = afterFailureCall,
        };
    }

    private static bool ExtractInterceptorField(
        INamedTypeSymbol classSymbol,
        SourceProductionContext context,
        Location location,
        out IFieldSymbol? interceptorField)
    {
        interceptorField = null;
        var interceptorFields = classSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(field => field.HasAttribute(InterceptorAttributeFullName))
            .ToArray();

        switch (interceptorFields.Length)
        {
            case 0:
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasNoInterceptor,
                        classSymbol.Locations.FirstOrDefault() ?? location,
                        classSymbol.Name));
                return false;

            case > 1:
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasMultipleInterceptors,
                        interceptorFields[1].Locations.FirstOrDefault() ?? location,
                        classSymbol.Name));
                return false;

            default:
                interceptorField = interceptorFields[0];
                return true;
        }
    }

    private static ProxyBeforeCallModel? ExtractBeforeCall(
        this TypeWithMembersModel type,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var found = type.Methods
            .Select(m => (
                method: m,
                attr: m.Attributes.FirstOrDefault(a => a.Type.FullName == typeof(InterceptBeforeAttribute).FullName)))
            .FirstOrDefault(m => m.attr is not null);

        if (found.attr is not { } attr) return null;

        var parameters = ExtractCallParameters(found.method, context, compilation, location);

        if (parameters == null) return null;

        return new ProxyBeforeCallModel()
        {
            Method = found.method,
            Parameters = parameters,
        };
    }

    private static ProxyAfterCallModel? ExtractAfterCall(
        this TypeWithMembersModel type,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var found = type.Methods
            .Select(m => (
                method: m,
                attr: m.Attributes.FirstOrDefault(a => a.Type.FullName == typeof(InterceptAfterAttribute).FullName)))
            .FirstOrDefault(m => m.attr is not null);

        if (found.attr is not { } attr) return null;

        var parameters = ExtractCallParameters(found.method, context, compilation, location);

        if (parameters is null) return null;

        return new ProxyAfterCallModel()
        {
            Method = found.method,
            Parameters = parameters,
        };
    }

    private static ProxyAfterSuccessCallModel? ExtractAfterSuccessCall(
        this TypeWithMembersModel type,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var found = type.Methods
            .Select(m => (
                method: m,
                attr: m.Attributes.FirstOrDefault(a =>
                    a.Type.FullName == typeof(InterceptAfterSuccessAttribute).FullName)))
            .FirstOrDefault(m => m.attr is not null);

        if (found.attr is not { } attr) return null;

        var parameters = ExtractCallParameters(found.method, context, compilation, location);

        if (parameters is null) return null;

        return new ProxyAfterSuccessCallModel()
        {
            Method = found.method,
            Parameters = parameters,
        };
    }

    private static ProxyAfterFailureCallModel? ExtractAfterFailureCall(
        this TypeWithMembersModel type,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var found = type.Methods
            .Select(m => (
                method: m,
                attr: m.Attributes.FirstOrDefault(a =>
                    a.Type.FullName == typeof(InterceptAfterFailureAttribute).FullName)))
            .FirstOrDefault(m => m.attr is not null);

        if (found.attr is not { } attr) return null;

        var parameters = ExtractCallParameters(found.method, context, compilation, location);

        if (parameters is null) return null;

        return new ProxyAfterFailureCallModel()
        {
            Method = found.method,
            Parameters = parameters,
        };
    }

    private static IReadOnlyList<ProxyInterceptorCallParameterModel>? ExtractCallParameters(
        MethodModel method,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        var parameters = new List<ProxyInterceptorCallParameterModel>();

        foreach (var parameter in method.Parameters)
        {
            var attributes = parameter.Symbol
                .ExtractAttributes(context, compilation, location);

            var hasInterceptedException = attributes
                .Any(a => a.Type.FullName == typeof(InterceptedExceptionAttribute).FullName!);

            var hasInterceptedInstance = attributes
                .Any(a => a.Type.FullName == typeof(InterceptedInstanceAttribute).FullName!);

            var interceptedMember = attributes
                .Where(a => a.Type.FullName == typeof(InterceptedMemberAttribute).FullName!)
                .Select(a =>
                {
                    var kind = GetMemberReferenceKind(parameter, context, compilation, location);

                    if (kind is null) return null;

                    return new ProxyInterceptorInterceptedMemberAttributeModel
                    {
                        ReferenceKind = kind.Value,
                    };
                })
                .FirstOrDefault();

            var interceptedParameter = attributes
                .Where(a => a.Type.FullName == typeof(InterceptedParameterAttribute).FullName!)
                .Select(a => new ProxyInterceptorInterceptedParameterAttributeModel
                {
                    Position = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Position))
                        .Select(na => na.Value.Value is int position ? position : default(int?))
                        .FirstOrDefault(),

                    Name = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Name))
                        .Select(na => na.Value.Value as string)
                        .FirstOrDefault(),

                    TypeName = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.TypeName))
                        .Select(na => na.Value.Value as string)
                        .FirstOrDefault(),

                    TypeNamespace = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.TypeNamespace))
                        .Select(na => na.Value.Value as string)
                        .FirstOrDefault(),

                    TypeFullName = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.TypeFullName))
                        .Select(na => na.Value.Value as string)
                        .FirstOrDefault(),

                    Type = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Type))
                        .Select(na => na.Value.Value is INamedTypeSymbol type ? type.ToTypeModel(context, compilation, location) : null)
                        .FirstOrDefault(),

                    Predicate = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Predicate))
                        .Select(na => na.Value.Value as string)
                        .FirstOrDefault(),
                })
                .FirstOrDefault();

            var interceptedParameters = attributes
                .Where(a => a.Type.FullName == typeof(InterceptedParametersAttribute).FullName!)
                .Select(a => new ProxyInterceptorInterceptedParametersAttributeModel
                {
                    AllowChanges = a.Data.NamedArguments
                        .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParametersAttributeModel.AllowChanges))
                        .Select(na => na.Value.Value is true)
                        .FirstOrDefault(),
                })
                .FirstOrDefault();

            var hasInterceptedProxyInstance = attributes
                .Any(a => a.Type.FullName == typeof(InterceptedProxyInstanceAttribute).FullName!);

            var interceptedProxyType = attributes
                .Where(a => a.Type.FullName == typeof(InterceptedProxyTypeAttribute).FullName!)
                .Select(a =>
                {
                    var kind = GetTypeReferenceKind(parameter, context, compilation, location);

                    if (kind is null) return null;

                    return new ProxyInterceptorInterceptedProxyTypeAttributeModel
                    {
                        ReferenceKind = kind.Value,
                    };
                })
                .FirstOrDefault();

            var hasInterceptedResult = attributes
                .Any(a => a.Type.FullName == typeof(InterceptedResultAttribute).FullName!);

            var hasInterceptedState = attributes
                .Any(a => a.Type.FullName == typeof(InterceptedStateAttribute).FullName!);

            var interceptedTarget = attributes
                .Where(a => a.Type.FullName == typeof(InterceptedTargetTypeAttribute).FullName!)
                .Select(a =>
                {
                    var kind = GetTypeReferenceKind(parameter, context, compilation, location);

                    if (kind is null) return null;

                    return new ProxyInterceptorInterceptedTargetTypeAttributeModel
                    {
                        ReferenceKind = kind.Value,
                    };
                })
                .FirstOrDefault();

            var activeAttributes = new[]
            {
                    hasInterceptedException ? nameof(InterceptedExceptionAttribute) : null,
                    hasInterceptedInstance ? nameof(InterceptedInstanceAttribute) : null,
                    interceptedMember is not null ? nameof(InterceptedMemberAttribute) : null,
                    interceptedParameter is not null ? nameof(InterceptedParameterAttribute) : null,
                    interceptedParameters is not null ? nameof(InterceptedParametersAttribute) : null,
                    hasInterceptedProxyInstance ? nameof(InterceptedProxyInstanceAttribute) : null,
                    interceptedProxyType is not null ? nameof(InterceptedProxyTypeAttribute) : null,
                    hasInterceptedResult ? nameof(InterceptedResultAttribute) : null,
                    hasInterceptedState ? nameof(InterceptedStateAttribute) : null,
                    interceptedTarget is not null ? nameof(InterceptedTargetTypeAttribute) : null,
                }.Where(e => e is not null).ToArray();

            if (activeAttributes.Length > 1)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        AopGeneratorUtils.DiagnosticDescriptors.MultipleInterceptionAttributes,
                        parameter.Symbol.Locations.FirstOrDefault() ?? location,
                        parameter.Symbol.Name,
                        string.Join(", ", activeAttributes)));

                return null;
            }

            if (activeAttributes.Length == 0)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        AopGeneratorUtils.DiagnosticDescriptors.NoInterceptionAttributes,
                        parameter.Symbol.Locations.FirstOrDefault() ?? location,
                        parameter.Symbol.Name));

                return null;
            }

            parameters.Add(new ProxyInterceptorCallParameterModel
            {
                Parameter = parameter,
                InterceptedException = hasInterceptedException ? ProxyInterceptorAttributeModel.Default : null,
                InterceptedInstance = hasInterceptedInstance ? ProxyInterceptorAttributeModel.Default : null,
                InterceptedMember = interceptedMember,
                InterceptedParameter = interceptedParameter,
                InterceptedParameters = interceptedParameters,
                InterceptedProxyInstance = hasInterceptedProxyInstance ? ProxyInterceptorAttributeModel.Default : null,
                InterceptedProxyType = interceptedProxyType,
                InterceptedResult = hasInterceptedResult ? ProxyInterceptorAttributeModel.Default : null,
                InterceptedState = hasInterceptedState ? ProxyInterceptorAttributeModel.Default : null,
                InterceptedTargetType = interceptedTarget,
            });
        }

        return parameters;
    }

    private static MemberReferenceKind? GetMemberReferenceKind(
        MethodParameterModel parameter,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        if (parameter.Type.FullName == "string")
            return MemberReferenceKind.String;

        if (parameter.Type.FullName == typeof(MethodInfo).FullName)
            return MemberReferenceKind.MethodInfo;

        context.ReportDiagnostic(
            Diagnostic.Create(
                AopGeneratorUtils.DiagnosticDescriptors.InterceptedMemberParameterTypeIsInvalid,
                parameter.Symbol.Locations.FirstOrDefault() ?? location,
                parameter.Symbol.Name,
                parameter.Type.FullName));

        return null;
    }

    private static TypeReferenceKind? GetTypeReferenceKind(
        MethodParameterModel parameter,
        SourceProductionContext context,
        Compilation compilation,
        Location location)
    {
        if (parameter.Type.FullName == "string")
            return TypeReferenceKind.String;

        if (parameter.Type.FullName == typeof(Type).FullName)
            return TypeReferenceKind.Type;

        context.ReportDiagnostic(
            Diagnostic.Create(
                AopGeneratorUtils.DiagnosticDescriptors.InterceptedTypeParameterTypeIsInvalid,
                parameter.Symbol.Locations.FirstOrDefault() ?? location,
                parameter.Symbol.Name,
                parameter.Type.FullName));

        return null;
    }

    #endregion [ Extract ]

    #region [ Generate ]

    /// <summary>
    /// Generate proxy class.
    /// Example:
    /// <code>
    /// // <auto-generated />
    ///
    /// #nullable enable
    ///
    /// namespace $Namespace;
    ///
    /// partial class $Name
    /// {
    ///     private static readonly System.Type ProxyType_Cache;
    ///
    ///     $InstanceConstructor
    ///
    ///     $StaticConstructor
    ///
    ///     $InterfaceImplementations
    /// }
    /// </summary>
    /// <param name="proxyModel"></param>
    /// <returns></returns>
    private static CompilationUnitSyntax GenerateProxyClass(ProxyGeneratorClassModel proxyModel)
    {
        CompilationUnitSyntax unitSyntax =
            CompilationUnit()
                .WithMembers(SingletonList(GetMainDeclaration()))
                .NormalizeWhitespace();

        return unitSyntax;


        // partial
        // -or-
        // < auto-generated />
        // #nullable enable
        // partial
        SyntaxTokenList GetProxyClassModifiers()
        {
            if (proxyModel.HasNamespace)
                return TokenList(Token(SyntaxKind.PartialKeyword));

            return TokenList(Token(
                GeneratorUtils.CreateAutoGeneratedHeaders(),
                SyntaxKind.PartialKeyword,
                TriviaList()));
        }

        // partial class $Name ...
        // -or-
        // namespace $Namespace;
        // partial class $Name ...
        MemberDeclarationSyntax GetMainDeclaration()
        {
            if (proxyModel.HasNamespace)
                return FileScopedNamespaceDeclaration(ParseName(proxyModel.Namespace!))
                    .WithNamespaceKeyword(Token(
                        GeneratorUtils.CreateAutoGeneratedHeaders(),
                        SyntaxKind.NamespaceKeyword,
                        TriviaList()))
                    .WithMembers(SingletonList<MemberDeclarationSyntax>(GetProxyClassDeclaration()));

            return GetProxyClassDeclaration();
        }

        // partial class $Name
        // {
        //     $ProxyClassMembers
        // }
        ClassDeclarationSyntax GetProxyClassDeclaration()
        {
            return ClassDeclaration(proxyModel.Name)
                .WithModifiers(GetProxyClassModifiers())
                .WithMembers(List(GetProxyClassMembers()));
        }

        IEnumerable<MemberDeclarationSyntax> GetProxyClassMembers()
        {
            if (proxyModel.ShouldGenerateProxyTypeName)
            {
                // private const string ProxyType_Name = nameof($Name);
                yield return ParseMemberDeclaration($"private const string {proxyModel.ProxyTypeNameName} = nameof({proxyModel.Name});")!;
            }

            if (proxyModel.ShouldGenerateProxyTypeCache)
            {
                // private static readonly System.Type ProxyType_Cache;
                yield return ParseMemberDeclaration($"private static readonly System.Type {proxyModel.ProxyTypeCacheName};")!;
            }

            yield return GenerateInstanceConstructor(proxyModel);

            yield return GenerateStaticConstructor(proxyModel);

            foreach (var @interface in proxyModel.Interfaces)
            {
                foreach (var member in GenerateInterfaceImplementation(proxyModel, @interface))
                {
                    yield return member;
                }
            }
        }
    }

    private static MemberDeclarationSyntax GenerateInstanceConstructor(ProxyGeneratorClassModel proxyModel)
    {
        return ConstructorDeclaration(proxyModel.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(ParameterList(SeparatedList(GetInstanceConstructorParameters())))
            .WithBody(Block(GetInstanceConstructorBody()));

        IEnumerable<ParameterSyntax> GetInstanceConstructorParameters()
        {
            foreach (var @interface in proxyModel.Interfaces)
            {
                // $InterfaceFullName $InterfaceParameterName
                yield return Parameter(Identifier(@interface.ParameterName))
                    .WithType(ParseTypeName(@interface.Type.FullName));
            }

            // $InterceptorFullName $InterceptorParameterName
            yield return Parameter(Identifier(proxyModel.Interceptor.ParameterName))
                .WithType(ParseTypeName(proxyModel.Interceptor.Type.FullName));
        }

        IEnumerable<StatementSyntax> GetInstanceConstructorBody()
        {
            foreach (var @interface in proxyModel.Interfaces)
            {
                // this.$InterfaceParameterName = $InterfaceParameterName;
                yield return ExpressionStatement(
                    ParseExpression($"this.{@interface.ParameterName} = {@interface.ParameterName}"));
            }

            // this.$InterceptorParameterName = $InterceptorParameterName;
            yield return ExpressionStatement(
                ParseExpression($"this.{proxyModel.Interceptor.ParameterName} = {proxyModel.Interceptor.ParameterName}"));
        }
    }

    private static MemberDeclarationSyntax GenerateStaticConstructor(ProxyGeneratorClassModel proxyModel)
    {
        return ConstructorDeclaration(proxyModel.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.StaticKeyword)))
            .WithBody(Block(GetStaticConstructorBody()));

        IEnumerable<StatementSyntax> GetStaticConstructorBody()
        {
            if (proxyModel.ShouldGenerateProxyTypeCache)
            {
                yield return GetProxyTypeCacheInitialization();
            }

            foreach (var @interface in proxyModel.Interfaces)
            {
                if (@interface.ShouldGenerateTargetTypeCache)
                {
                    yield return GetTargetTypeCacheInitialization(@interface);
                }

                foreach (var method in @interface.Methods)
                {
                    if (method.ShouldGenerateMethodCache)
                    {
                        yield return GetMethodCacheInitialization(@interface, method);
                    }
                }
            }
        }

        StatementSyntax GetProxyTypeCacheInitialization()
        {
            // ProxyType_Cache = typeof($Name);

            return ExpressionStatement(
                ParseExpression($"{proxyModel.ProxyTypeCacheName} = typeof({proxyModel.Name})"));
        }

        StatementSyntax GetTargetTypeCacheInitialization(ProxyGeneratorInterfaceModel @interface)
        {
            // $TargetTypeCacheName = typeof($InterfaceFullName);
            return ExpressionStatement(
                ParseExpression($"{@interface.TargetTypeCacheName} = typeof({@interface.Type.FullName})"));
        }

        StatementSyntax GetMethodCacheInitialization(
            ProxyGeneratorInterfaceModel @interface,
            ProxyGeneratorInterfaceMethodModel method)
        {
            // $MethodCacheName =
            //      IProxyGeneratorInterface_TargetType_Cache!.GetMethod(
            //          name: MyMethod_0_Name,
            //          bindingAttr: System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,
            //          binder: null,
            //          genericParameterCount: 0,
            //          callConvention: System.Reflection.CallingConventions.Any,
            //          types: new System.Type[]
            //          {
            //              typeof(string),
            //              typeof(int),
            //          },
            //          modifiers: null)!;

            var getMethodCall = InvocationExpression(
                    ParseExpression($"{@interface.TargetTypeCacheName}!.GetMethod"))
                .WithArgumentList(ArgumentList(SeparatedList(GetArgumentList())));

            return ExpressionStatement(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    IdentifierName(method.MethodCacheName),
                    PostfixUnaryExpression(
                        SyntaxKind.SuppressNullableWarningExpression,
                        getMethodCall)));

            IEnumerable<ArgumentSyntax> GetArgumentList()
            {
                // name: MyMethod_0_Name,
                yield return Argument(IdentifierName(method.MethodNameConstName))
                    .WithNameColon(NameColon(IdentifierName("name")));

                // bindingAttr: System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,
                yield return Argument(ParseExpression("System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance"))
                    .WithNameColon(NameColon(IdentifierName("bindingAttr")));

                // binder: null,
                yield return Argument(LiteralExpression(SyntaxKind.NullLiteralExpression))
                    .WithNameColon(NameColon(IdentifierName("binder")));

                // genericParameterCount: 0,
                yield return Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)))
                    .WithNameColon(NameColon(IdentifierName("genericParameterCount")));

                // callConvention: System.Reflection.CallingConventions.Any,
                yield return Argument(ParseExpression("System.Reflection.CallingConventions.Any"))
                    .WithNameColon(NameColon(IdentifierName("callConvention")));

                // types: new System.Type[] {...} -or- types: System.Array.Empty<System.Type>(),
                if (method.Method.Parameters is { Count: > 0 })
                {
                    yield return Argument(
                            ArrayCreationExpression(
                                    ArrayType(ParseTypeName("System.Type"))
                                        .WithRankSpecifiers(SingletonList(
                                            ArrayRankSpecifier(SingletonSeparatedList<ExpressionSyntax>(
                                                OmittedArraySizeExpression())))))
                                .WithInitializer(
                                    InitializerExpression(
                                        SyntaxKind.ArrayInitializerExpression,
                                        SeparatedList(GetTypesExpressions()))))
                        .WithNameColon(NameColon(IdentifierName("types")));
                }
                else
                {
                    yield return Argument(ParseExpression("System.Array.Empty<System.Type>()"))
                        .WithNameColon(NameColon(IdentifierName("types")));
                }

                // modifiers: null,
                yield return Argument(LiteralExpression(SyntaxKind.NullLiteralExpression))
                    .WithNameColon(NameColon(IdentifierName("modifiers")));


                IEnumerable<ExpressionSyntax> GetTypesExpressions()
                {
                    foreach (var parameter in method.Method.Parameters)
                    {
                        var fullName = parameter.Type.FullName;
                        if (fullName.EndsWith("?"))
                        {
                            fullName = fullName.Substring(0, fullName.Length - 1);
                        }
                        yield return ParseExpression($"typeof({fullName})");
                    }
                }
            }
        }
    }

    private static IEnumerable<MemberDeclarationSyntax> GenerateInterfaceImplementation(
        ProxyGeneratorClassModel proxyModel,
        ProxyGeneratorInterfaceModel @interface)
    {
        // private readonly $InterfaceFullName $InterfaceParameterName;
        yield return ParseMemberDeclaration($"private readonly {@interface.Type.FullName} {@interface.ParameterName};")!;

        if (@interface.ShouldGenerateTargetTypeName)
        {
            // private const string $InterfaceName_TargetType_Name = nameof($InterfaceFullName);
            yield return ParseMemberDeclaration($"private const string {@interface.TargetTypeNameName} = nameof({@interface.Type.FullName});")!;
        }

        if (@interface.ShouldGenerateTargetTypeCache)
        {
            // private static readonly System.Type IProxyGeneratorInterface_TargetType_Cache;
            yield return ParseMemberDeclaration($"private static readonly System.Type {@interface.TargetTypeCacheName};")!;
        }

        foreach (var method in @interface.Methods)
        {
            if (method.ShouldGenerateMethodName)
            {
                // private const string $MethodName_$MethodIndex_Name = nameof($InterfaceFullName.$MethodName);
                yield return ParseMemberDeclaration($"private const string {method.MethodNameConstName} = nameof({@interface.Type.FullName}.{method.Method.Name});")!;
            }

            if (method.ShouldGenerateMethodCache)
            {
                // private static readonly System.Reflection.MethodInfo MyMethod_0_Cache;
                yield return ParseMemberDeclaration($"private static readonly System.Reflection.MethodInfo {method.MethodCacheName};")!;
            }

            yield return GenerateInterfaceMethodImplementation(proxyModel, @interface, method);
        }
    }

    // $ReturnType $InterfaceFullName.$MethodName($Parameters) { $Interception }
    private static MemberDeclarationSyntax GenerateInterfaceMethodImplementation(
        ProxyGeneratorClassModel proxyModel,
        ProxyGeneratorInterfaceModel @interface,
        ProxyGeneratorInterfaceMethodModel method)
    {
        var methodDeclaration = MethodDeclaration(
                ParseTypeName(method.Method.ReturnType.FullName),
                Identifier(method.Method.Name))
            .WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifier(
                ParseName(@interface.Type.FullName)))
            .WithParameterList(ParameterList(SeparatedList(GetParameters())))
            .WithBody(Block(GetStatements()));

        if (method.IsAsync)
            methodDeclaration = methodDeclaration
                .WithModifiers(TokenList(Token(SyntaxKind.AsyncKeyword)));

        return methodDeclaration;


        IEnumerable<ParameterSyntax> GetParameters()
        {
            foreach (var parameter in method.Method.Parameters)
            {
                yield return Parameter(Identifier(parameter.Name))
                    .WithType(ParseTypeName(parameter.Type.FullName));
            }
        }

        IEnumerable<StatementSyntax> GetStatements()
        {
            foreach (var statement in GenerateBeforeCall())
            {
                yield return statement;
            }

            if (proxyModel.Interceptor.HasAfterCalls)
            {
                // try
                // {
                //     [var result = ]$OriginalMethodCall;
                //     $InterceptorParameterName.AfterSuccessCall(..., result, state);
                //     [return result;]
                // }
                // catch (System.Exception exception)
                // {
                //     [var result = ]$InterceptorParameterName.AfterFailureCall(..., exception, state);
                //     throw; -or- return result;
                // }
                // finally
                // {
                //     $InterceptorParameterName.AfterCall(..., state);
                // }

                if (proxyModel.Interceptor.AfterCall is null &&
                    proxyModel.Interceptor.AfterFailureCall is null)
                {
                    // No need for try-catch-finally
                    foreach (var statement in GetTryStatements())
                    {
                        yield return statement;
                    }
                }
                else
                {
                    yield return TryStatement(
                        Block(List(GetTryStatements())),
                        List(GetCatchClauses()),
                        GetFinallyClause());
                }
            }
            else
            {
                // [return ]$OriginalMethodCall;
                yield return GetSimplifiedCall();
            }

            StatementSyntax GetSimplifiedCall()
            {
                if (method.ResultType.IsVoid)
                {
                    // [await ]this.$InterfaceParameterName.$MethodName($Parameters);
                    return ExpressionStatement(GetOriginalMethodCall());
                }
                else
                {
                    // return [await ]this.$InterfaceParameterName.$MethodName($Parameters);
                    return ReturnStatement(GetOriginalMethodCall());
                }
            }

            IEnumerable<StatementSyntax> GetTryStatements()
            {
                if (proxyModel.Interceptor.AfterSuccessCall is { } afterSuccessCall)
                {
                    // [var result = ]$OriginalMethodCall;
                    // $InterceptorParameterName.AfterSuccessCall(..., result, state);
                    // [return result;]
                    if (method.ResultType.IsVoid)
                    {
                        yield return ExpressionStatement(
                            GetOriginalMethodCall());
                    }
                    else
                    {
                        yield return LocalDeclarationStatement(
                            VariableDeclaration(IdentifierName("var"))
                                .WithVariables(SingletonSeparatedList(
                                    VariableDeclarator(Identifier("result"))
                                        .WithInitializer(EqualsValueClause(
                                            GetOriginalMethodCall())))));
                    }

                    var afterSuccessExpression =
                        InvocationExpression(
                                ParseExpression($"{proxyModel.Interceptor.ParameterName}.{afterSuccessCall.Name}"))
                            .WithArgumentList(ArgumentList(SeparatedList(
                                GetInterceptorArguments(afterSuccessCall.Parameters, isAfterCall: true,
                                    isSuccess: true))));

                    yield return ExpressionStatement(afterSuccessExpression);

                    if (!method.ResultType.IsVoid)
                    {
                        yield return ReturnStatement(IdentifierName("result"));
                    }
                }
                else
                {
                    // [return ]$OriginalMethodCall;
                    yield return GetSimplifiedCall();
                }
            }

            IEnumerable<CatchClauseSyntax> GetCatchClauses()
            {
                if (proxyModel.Interceptor.AfterFailureCall is not { } afterFailure) yield break;

                // catch (System.Exception exception) { ... }
                yield return CatchClause()
                    .WithDeclaration(
                        CatchDeclaration(ParseName(typeof(Exception).FullName!))
                            .WithIdentifier(Identifier("exception")))
                    .WithBlock(Block(GetCatchStatements(afterFailure)));
            }

            IEnumerable<StatementSyntax> GetCatchStatements(ProxyAfterFailureCallModel afterFailure)
            {
                // $InterceptorParameterName.AfterFailureCall(..., exception, state);
                // throw;

                var callExpression =
                    InvocationExpression(
                            ParseExpression($"{proxyModel.Interceptor.ParameterName}.{afterFailure.Name}"))
                        .WithArgumentList(ArgumentList(SeparatedList(
                            GetInterceptorArguments(afterFailure.Parameters, isAfterCall: true, isFailure: true))));

                yield return ExpressionStatement(callExpression);
                yield return ThrowStatement();
            }

            FinallyClauseSyntax? GetFinallyClause()
            {
                if (proxyModel.Interceptor.AfterCall is not { } afterCall) return null;

                var afterCallExpression =
                    InvocationExpression(
                            ParseExpression($"{proxyModel.Interceptor.ParameterName}.{afterCall.Name}"))
                        .WithArgumentList(ArgumentList(SeparatedList(
                            GetInterceptorArguments(afterCall.Parameters, isAfterCall: true))));

                return FinallyClause(Block(SingletonList(
                    ExpressionStatement(afterCallExpression))));
            }
        }

        IEnumerable<StatementSyntax> GenerateBeforeCall()
        {
            if (proxyModel.Interceptor.BeforeCall is not { } beforeCall) yield break;

            // var parameters = new object?[] { $Parameters };
            // 
            // [var state = ]$InterceptorParameterName.BeforeCall(
            //     proxyType: ProxyType_Cache,
            //     proxyTypeName: ProxyType_Name,
            //     proxyInstance: this,
            //     instance: $InterfaceParameterName,
            //     targetType: $InterfaceName_TargetType_Name,
            //     targetTypeName: $InterfaceName_TargetType_Cache,
            //     methodInfo: MyMethod_0_Cache,
            //     methodName: MyMethod_0_Name,
            //     parameters: new object[] { $Parameters });

            if (proxyModel.Interceptor.HasParametersArgument)
            {
                // var parameters = new object[] { $Parameters };
                var parameters = method.Method.Parameters
                    .Select(p => ParseExpression(p.Name));

                var parameterArray =
                    ArrayCreationExpression(
                            ArrayType(ParseTypeName("object?"))
                                .WithRankSpecifiers(SingletonList(
                                    ArrayRankSpecifier(SingletonSeparatedList<ExpressionSyntax>(
                                        OmittedArraySizeExpression())))))
                        .WithInitializer(
                            InitializerExpression(
                                SyntaxKind.ArrayInitializerExpression,
                                SeparatedList(parameters)));

                yield return LocalDeclarationStatement(
                    VariableDeclaration(ParseTypeName("var"))
                        .WithVariables(SingletonSeparatedList(
                            VariableDeclarator(Identifier("parameters"))
                                .WithInitializer(EqualsValueClause(parameterArray)))));
            }

            var callExpression =
                InvocationExpression(
                        ParseExpression($"{proxyModel.Interceptor.ParameterName}.{beforeCall.Name}"))
                    .WithArgumentList(ArgumentList(SeparatedList(
                        GetInterceptorArguments(beforeCall.Parameters))));

            if (proxyModel.Interceptor.HasState)
            {
                yield return LocalDeclarationStatement(
                    VariableDeclaration(ParseTypeName("var"))
                        .WithVariables(SingletonSeparatedList(
                            VariableDeclarator(Identifier("state"))
                                .WithInitializer(EqualsValueClause(callExpression)))));
            }
            else
            {
                yield return ExpressionStatement(callExpression);
            }

        }

        ExpressionSyntax GetOriginalMethodCall()
        {
            ExpressionSyntax call = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(@interface.ParameterName),
                    IdentifierName(method.Method.Name)))
                .WithArgumentList(ArgumentList(SeparatedList(
                    GetInterceptedArgumentList())));

            if (method.IsAsync)
            {
                call = AwaitExpression(call);
            }

            return call;
        }

        IEnumerable<ArgumentSyntax> GetInterceptedArgumentList()
        {
            // TODO: If parameters could change, take the values from parameters[i] instead
            if (proxyModel.Interceptor.BeforeCall?.ParametersArgument?.InterceptedParameters?.AllowChanges == true)
            {
                for (int i = 0; i < method.Method.Parameters.Count; i++)
                {
                    var parameter = method.Method.Parameters[i];
                    yield return Argument(ParseExpression($"({parameter.Type.FullName})parameters[{i}]"));
                }
            }
            else
            {
                foreach (var parameter in method.Method.Parameters)
                {
                    yield return Argument(IdentifierName(parameter.Name));
                }
            }
        }

        IEnumerable<ArgumentSyntax> GetInterceptorArguments(
            IReadOnlyList<ProxyInterceptorCallParameterModel> parameters,
            bool isAfterCall = false,
            bool isSuccess = false,
            bool isFailure = false)
        {
            foreach (var parameter in parameters)
            {
                yield return Argument(GetParameterValue(parameter))
                    .WithNameColon(NameColon(IdentifierName(parameter.Name)));
            }

            ExpressionSyntax GetParameterValue(ProxyInterceptorCallParameterModel parameter)
            {
                if (parameter.InterceptedProxyType is {} interceptedProxyType)
                {
                    switch (interceptedProxyType.ReferenceKind)
                    {
                        case TypeReferenceKind.String:
                            // ProxyType_Name
                            return ParseExpression(@$"{proxyModel.ProxyTypeNameName}");

                        case TypeReferenceKind.Type:
                            // ProxyType_Cache
                            return ParseExpression(@$"{proxyModel.ProxyTypeCacheName}");
                    }
                }

                if (parameter.InterceptedProxyInstance is not null)
                {
                    return ParseExpression("this");
                }

                if (parameter.InterceptedInstance is not null)
                {
                    // $InterfaceParameterName
                    return ParseExpression(@$"{@interface.ParameterName}");
                }

                if (parameter.InterceptedTargetType is { } interceptedTargetType)
                {
                    switch (interceptedTargetType.ReferenceKind)
                    {
                        case TypeReferenceKind.String:
                            // $InterfaceName_TargetType_Name
                            return ParseExpression(@$"{@interface.TargetTypeNameName}");

                        case TypeReferenceKind.Type:
                            // $InterfaceName_TargetType_Cache
                            return ParseExpression(@$"{@interface.TargetTypeCacheName}");
                    }
                }

                if (parameter.InterceptedMember is {} interceptedMember)
                {
                    switch (interceptedMember.ReferenceKind)
                    {
                        case MemberReferenceKind.String:
                            // MyMethod_0_Name
                            return ParseExpression(@$"{method.MethodNameConstName}");

                        case MemberReferenceKind.MethodInfo:
                            // MyMethod_0_Cache
                            return ParseExpression(@$"{method.MethodCacheName}");
                    }
                }

                if (parameter.InterceptedParameters is not null)
                {
                    // parameters
                    return ParseExpression("parameters");
                }

                if (isAfterCall)
                {
                    if (isSuccess &&
                        parameter.InterceptedResult is not null &&
                        !method.ResultType.IsVoid)
                    {
                        // result;
                        return ParseExpression("result");
                    }

                    if (parameter.InterceptedState is not null &&
                        proxyModel.Interceptor.HasState)
                    {
                        // state;
                        return ParseExpression("state");
                    }

                    if (isFailure &&
                        parameter.InterceptedException is not null)
                    {
                        // state;
                        return ParseExpression("exception");
                    }
                }

                // default!
                return LiteralExpression(SyntaxKind.DefaultLiteralExpression);
            }
        }
    }

    #endregion [ Generate ]

    #endregion [ RegisterProxyClasses ]
}
