using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Reflection.Metadata;
using System.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace MicroCs.Generators.Aop;

internal static class ProxyGeneratorUtils
{
    #region [ Attributes Full Names ]

    private const string GenerateProxyAttributeFullName =
        $"{AopGeneratorUtils.MainNamespace}.GenerateProxyAttribute";

    private const string InterceptorAttributeFullName =
        $"{AopGeneratorUtils.MainNamespace}.InterceptorAttribute";

    #endregion [ Attributes Full Names ]

    #region [ RegisterProxyAttributes ]

    public static void RegisterProxyAttributes(
        this IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(AddAttributesSource);

    private static void AddAttributesSource(
        IncrementalGeneratorPostInitializationContext context)
    {
        var model = new ProxyGeneratorAttributesModel
        {
            Namespace = AopGeneratorUtils.MainNamespace,
        };

        var attributesSource = RenderAttributesSource(model);

        context.AddSource(
            "ProxyGeneratorAttributes.g.cs",
            SourceText.From(attributesSource, Encoding.UTF8));
    }

    private static string RenderAttributesSource(ProxyGeneratorAttributesModel model)
    {
        var builder = new IndentedStringBuilder();

        builder.AppendLine(
            """
            // <auto-generated />

            #nullable enable

            """);
        builder.AppendLine($"namespace {model.Namespace}");
        builder.AppendLine(
            """
            {   // OK
                [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
                internal sealed class GenerateProxyAttribute : System.Attribute
                {
                }
            
                [System.AttributeUsage(System.AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
                internal sealed class InterceptorAttribute : System.Attribute
                {
                }
            }
            """);

        return builder.ToString();
    }

    #endregion [ RegisterProxyAttributes ]

    #region [ RegisterProxyClasses ]

    public static void RegisterProxyClasses(
        this IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                PartialClassWithBaseTypesAndAttributes,
                HasGenerateProxyAttribute)
            .Where(e => e is not null)
            .Select((e, _) => e!);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(classes.Collect()),
            GenerateProxyClasses);
    }

    private static bool PartialClassWithBaseTypesAndAttributes(
        SyntaxNode node,
        CancellationToken cancel)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } @class &&
               @class.Modifiers.Any(SyntaxKind.PartialKeyword) &&
               !@class.Modifiers.Any(SyntaxKind.StaticKeyword) &&
               @class.BaseList?.Types is { Count: > 0 };
    }

    private static ClassDeclarationSyntax? HasGenerateProxyAttribute(
        GeneratorSyntaxContext context,
        CancellationToken cancel)
    {
        if (context.Node is not ClassDeclarationSyntax @class) return null;

        var hasGenerateProxyAttribute = @class
            .HasAttribute(GenerateProxyAttributeFullName, context.SemanticModel);

        return hasGenerateProxyAttribute ? @class : null;
    }

    private static void GenerateProxyClasses(
        SourceProductionContext context,
        (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes) data)
    {
        var models = data.classes.ExtractClassModels(context, data.compilation);

        for (int i = 0; i < models.Count; i++)
        {
            var model = models[i];
            if (!model.ShouldGenerateCode) continue;
            var fileName = $"{model.Name}.{i}.g.cs";
            var tree = GenerateProxyClass(model);
            var source = tree.GetText(Encoding.UTF8);
            context.AddSource(fileName, source);
        }
    }

    #region [ Extract ]

    private static IReadOnlyList<ProxyGeneratorClassModel> ExtractClassModels(
        this ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context,
        Compilation compilation)
    {
        return classes
            .Select(classSyntax => classSyntax.ExtractGeneratorClassModel(context, compilation))
            .Where(model => model is not null)
            .Select(model => model!)
            .ToArray();
    }

    private static ProxyGeneratorClassModel? ExtractGeneratorClassModel(
        this ClassDeclarationSyntax classSyntax,
        SourceProductionContext context,
        Compilation compilation)
    {
        var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);

        if (semanticModel.GetDeclaredSymbol(classSyntax) is not { } classSymbol)
            return null;

        var className = classSymbol.Name;
        var @namespace = classSymbol.ContainingNamespace?.ToDisplayString();

        var interfaces = classSymbol.AllInterfaces
            .Select(interfaceSymbol => interfaceSymbol.ExtractProxyInterfaceModel(context, compilation))
            .Where(model => model is not null)
            .Select(model => model!)
            .ToArray();

        if (interfaces.Length == 0)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasNoInterfaces,
                    classSyntax.GetLocation(),
                    className));
            return null;
        }

        var interceptor = classSymbol.ExtractInterceptorModel(context, compilation);

        if (interceptor is null) return null;

        return new ProxyGeneratorClassModel
        {
            Namespace = @namespace,
            Name = className,
            Interfaces = interfaces,
            Interceptor = interceptor,
        };
    }

    private static ProxyGeneratorInterfaceModel? ExtractProxyInterfaceModel(
        this INamedTypeSymbol typeSymbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        var type = typeSymbol.ExtractTypeWithMembersModel(context, compilation);

        if (type is null) return null;

        var methods = type.Methods
            .Select((method, index) =>
            {
                var asyncInfo = method.ReturnType.Symbol.GetAsyncInfo(context, compilation);

                return new ProxyGeneratorInterfaceMethodModel
                {
                    Method = method,
                    Index = index,
                    IsAsync = asyncInfo.IsAsync,
                    ResultType = asyncInfo.InnerType ?? method.ReturnType,
                };
            })
            .ToArray();

        return new ProxyGeneratorInterfaceModel
        {
            ParameterName = typeSymbol.Name.ToParameterName(),
            Type = type,
            Methods = methods,
        };
    }

    private static ProxyGeneratorInterceptorModel? ExtractInterceptorModel(
        this INamedTypeSymbol classSymbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        if (!ExtractInterceptorField(classSymbol, context, out var interceptorField)) return null;

        if (interceptorField!.Type is not INamedTypeSymbol interceptorTypeSymbol)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyInterceptorIsNotNamedType,
                    interceptorField.Locations[0],
                    classSymbol.Name));

            return null;
        }

        var interceptorType = interceptorTypeSymbol
            .ExtractTypeWithMembersModel(context, compilation);

        if (interceptorType is null) return null;

        var beforeCall = interceptorType.ExtractBeforeCall(context, compilation);

        return new ProxyGeneratorInterceptorModel
        {
            ParameterName = interceptorField.Name.ToParameterName(),
            Type = interceptorType,
            BeforeCall = beforeCall,
        };
    }

    private static bool ExtractInterceptorField(
        INamedTypeSymbol classSymbol,
        SourceProductionContext context,
        out IFieldSymbol? interceptorField)
    {
        interceptorField = null;
        var interceptorFields = classSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(field => field.HasAttribute(InterceptorAttributeFullName))
            .ToArray();

        switch (interceptorFields.Length)
        {
            case 0:
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasNoInterceptor,
                        classSymbol.Locations[0],
                        classSymbol.Name));
                return false;

            case > 1:
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasMultipleInterceptors,
                        interceptorFields[1].Locations[0],
                        classSymbol.Name));
                return false;

            default:
                interceptorField = interceptorFields[0];
                return true;
        }
    }

    private static ProxyBeforeCallModel? ExtractBeforeCall(
        this TypeWithMembersModel type,
        SourceProductionContext context,
        Compilation compilation)
    {
        var found = type.Methods
            .Select(m => (
                method: m,
                attr: m.Attributes.FirstOrDefault(a => a.Type.FullName == typeof(InterceptBeforeAttribute).FullName)))
            .FirstOrDefault(m => m.attr is not null);

        if (found.attr is not { } attr) return null;

        var parameters = ExtractCallParameters(found.method, context, compilation);

        return new ProxyBeforeCallModel()
        {
            Method = found.method,
            Parameters = parameters,
        };
    }

    private static IReadOnlyList<ProxyInterceptorCallParameterModel> ExtractCallParameters(
        MethodModel method,
        SourceProductionContext context,
        Compilation compilation)
    {
        return method.Parameters
            .Select(parameter =>
            {
                var attributes = parameter.Symbol.ExtractAttributes(context, compilation);

                var hasInterceptedException = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedExceptionAttribute).FullName!);

                var hasInterceptedInstance = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedInstanceAttribute).FullName!);

                var hasInterceptedMember = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedMemberAttribute).FullName!);

                var interceptedParameter = attributes
                    .Where(a => a.Type.FullName == typeof(InterceptedParameterAttribute).FullName!)
                    .Select(a => new ProxyInterceptorInterceptedParameterAttributeModel
                    {
                        Position = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Position))
                            .Select(na => na.Value.Value is int position ? position : default(int?))
                            .FirstOrDefault(),

                        Name = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Name))
                            .Select(na => na.Value.Value is string name ? name : default(string?))
                            .FirstOrDefault(),

                        TypeName = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.TypeName))
                            .Select(na => na.Value.Value is string typeName ? typeName : default(string?))
                            .FirstOrDefault(),

                        TypeNamespace = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.TypeNamespace))
                            .Select(na => na.Value.Value is string typeNamespace ? typeNamespace : default(string?))
                            .FirstOrDefault(),

                        TypeFullName = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.TypeFullName))
                            .Select(na => na.Value.Value is string typeFullName ? typeFullName : default(string?))
                            .FirstOrDefault(),

                        Type = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Type))
                            .Select(na => na.Value.Value is INamedTypeSymbol type ? type.ToNamedTypeModel(context, compilation) : null)
                            .FirstOrDefault(),

                        Predicate = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParameterAttributeModel.Predicate))
                            .Select(na => na.Value.Value is string predicate ? predicate : default(string?))
                            .FirstOrDefault(),
                    })
                    .FirstOrDefault();

                var interceptedParameters = attributes
                    .Where(a => a.Type.FullName == typeof(InterceptedParametersAttribute).FullName!)
                    .Select(a => new ProxyInterceptorInterceptedParametersAttributeModel
                    {
                        AllowChanges = a.Data.NamedArguments
                            .Where(na => na.Key == nameof(ProxyInterceptorInterceptedParametersAttributeModel.AllowChanges))
                            .Select(na => na.Value.Value is true)
                            .FirstOrDefault(),
                    })
                    .FirstOrDefault();

                var hasInterceptedProxyInstance = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedProxyInstanceAttribute).FullName!);

                var hasInterceptedProxyType = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedProxyTypeAttribute).FullName!);

                var hasInterceptedResult = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedResultAttribute).FullName!);

                var hasInterceptedState = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedStateAttribute).FullName!);

                var hasInterceptedTarget = attributes
                    .Any(a => a.Type.FullName == typeof(InterceptedTargetTypeAttribute).FullName!);

                var activeAttributes = new[]
                {
                    hasInterceptedException ? nameof(InterceptedExceptionAttribute) : null,
                    hasInterceptedInstance ? nameof(InterceptedInstanceAttribute) : null,
                    hasInterceptedMember ? nameof(InterceptedMemberAttribute) : null,
                    interceptedParameter is not null ? nameof(InterceptedParameterAttribute) : null,
                    interceptedParameters is not null ? nameof(InterceptedParametersAttribute) : null,
                    hasInterceptedProxyInstance ? nameof(InterceptedProxyInstanceAttribute) : null,
                    hasInterceptedProxyType ? nameof(InterceptedProxyTypeAttribute) : null,
                    hasInterceptedResult ? nameof(InterceptedResultAttribute) : null,
                    hasInterceptedState ? nameof(InterceptedStateAttribute) : null,
                    hasInterceptedTarget ? nameof(InterceptedTargetTypeAttribute) : null,
                }.Where(e => e is not null).ToArray();

                if (activeAttributes.Length > 1)
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            AopGeneratorUtils.DiagnosticDescriptors.MultipleInterceptionAttributes,
                            parameter.Symbol.Locations[0],
                            parameter.Symbol.Name,
                            string.Join(", ", activeAttributes)));
                }

                if (activeAttributes.Length == 0)
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            AopGeneratorUtils.DiagnosticDescriptors.NoInterceptionAttributes,
                            parameter.Symbol.Locations[0],
                            parameter.Symbol.Name));
                }

                return new ProxyInterceptorCallParameterModel
                {
                    Parameter = parameter,
                    InterceptedException = hasInterceptedException ? ProxyInterceptorAttributeModel.Default : null,
                    InterceptedInstance = hasInterceptedInstance ? ProxyInterceptorAttributeModel.Default : null,
                    InterceptedMember = hasInterceptedMember ? ProxyInterceptorAttributeModel.Default : null,
                    InterceptedParameter = interceptedParameter,
                    InterceptedParameters = interceptedParameters,
                    InterceptedProxyInstance = hasInterceptedProxyInstance ? ProxyInterceptorAttributeModel.Default : null,
                    InterceptedProxyType = hasInterceptedProxyType ? ProxyInterceptorAttributeModel.Default : null,
                    InterceptedResult = hasInterceptedResult ? ProxyInterceptorAttributeModel.Default : null,
                    InterceptedState = hasInterceptedState ? ProxyInterceptorAttributeModel.Default : null,
                    InterceptedTargetType = hasInterceptedTarget ? ProxyInterceptorAttributeModel.Default : null,
                };
            })
            .ToArray();
    }

    #endregion [ Extract ]

    #region [ Generate ]

    /// <summary>
    /// Generate proxy class.
    /// Example:
    /// <code>
    /// // <auto-generated />
    ///
    /// #nullable enable
    ///
    /// namespace $Namespace;
    ///
    /// partial class $Name
    /// {
    ///     private static readonly System.Type ProxyType_Cache;
    ///
    ///     $InstanceConstructor
    ///
    ///     $StaticConstructor
    ///
    ///     $InterfaceImplementations
    /// }
    /// </summary>
    /// <param name="proxyModel"></param>
    /// <returns></returns>
    private static CompilationUnitSyntax GenerateProxyClass(ProxyGeneratorClassModel proxyModel)
    {
        CompilationUnitSyntax unitSyntax =
            CompilationUnit()
                .WithMembers(SingletonList(GetMainDeclaration()))
                .NormalizeWhitespace();

        return unitSyntax;


        // partial
        // -or-
        // < auto-generated />
        // #nullable enable
        // partial
        SyntaxTokenList GetProxyClassModifiers()
        {
            if (proxyModel.HasNamespace)
                return TokenList(Token(SyntaxKind.PartialKeyword));

            return TokenList(Token(
                GeneratorUtils.CreateAutoGeneratedHeaders(),
                SyntaxKind.PartialKeyword,
                TriviaList()));
        }

        // partial class $Name ...
        // -or-
        // namespace $Namespace;
        // partial class $Name ...
        MemberDeclarationSyntax GetMainDeclaration()
        {
            if (proxyModel.HasNamespace)
                return FileScopedNamespaceDeclaration(ParseName(proxyModel.Namespace!))
                    .WithNamespaceKeyword(Token(
                        GeneratorUtils.CreateAutoGeneratedHeaders(),
                        SyntaxKind.NamespaceKeyword,
                        TriviaList()))
                    .WithMembers(SingletonList<MemberDeclarationSyntax>(GetProxyClassDeclaration()));

            return GetProxyClassDeclaration();
        }

        // partial class $Name
        // {
        //     $ProxyClassMembers
        // }
        ClassDeclarationSyntax GetProxyClassDeclaration()
        {
            return ClassDeclaration(proxyModel.Name)
                .WithModifiers(GetProxyClassModifiers())
                .WithMembers(List(GetProxyClassMembers()));
        }

        IEnumerable<MemberDeclarationSyntax> GetProxyClassMembers()
        {
            if (proxyModel.ShouldGenerateProxyTypeName)
            {
                // private const string ProxyType_Name = nameof($Name);
                yield return ParseMemberDeclaration($"private const string {proxyModel.ProxyTypeNameName} = nameof({proxyModel.Name});")!;
            }

            if (proxyModel.ShouldGenerateProxyTypeCache)
            {
                // private static readonly System.Type ProxyType_Cache;
                yield return ParseMemberDeclaration($"private static readonly System.Type {proxyModel.ProxyTypeCacheName};")!;
            }

            yield return GenerateInstanceConstructor(proxyModel);

            yield return GenerateStaticConstructor(proxyModel);

            foreach (var @interface in proxyModel.Interfaces)
            {
                foreach (var member in GenerateInterfaceImplementation(proxyModel, @interface))
                {
                    yield return member;
                }
            }
        }
    }

    private static MemberDeclarationSyntax GenerateInstanceConstructor(ProxyGeneratorClassModel proxyModel)
    {
        return ConstructorDeclaration(proxyModel.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(ParameterList(SeparatedList(GetInstanceConstructorParameters())))
            .WithBody(Block(GetInstanceConstructorBody()));

        IEnumerable<ParameterSyntax> GetInstanceConstructorParameters()
        {
            foreach (var @interface in proxyModel.Interfaces)
            {
                // $InterfaceFullName $InterfaceParameterName
                yield return Parameter(Identifier(@interface.ParameterName))
                    .WithType(ParseTypeName(@interface.Type.FullName));
            }

            // $InterceptorFullName $InterceptorParameterName
            yield return Parameter(Identifier(proxyModel.Interceptor.ParameterName))
                .WithType(ParseTypeName(proxyModel.Interceptor.Type.FullName));
        }

        IEnumerable<StatementSyntax> GetInstanceConstructorBody()
        {
            foreach (var @interface in proxyModel.Interfaces)
            {
                // this.$InterfaceParameterName = $InterfaceParameterName;
                yield return ExpressionStatement(
                    ParseExpression($"this.{@interface.ParameterName} = {@interface.ParameterName}"));
            }

            // this.$InterceptorParameterName = $InterceptorParameterName;
            yield return ExpressionStatement(
                ParseExpression($"this.{proxyModel.Interceptor.ParameterName} = {proxyModel.Interceptor.ParameterName}"));
        }
    }

    private static MemberDeclarationSyntax GenerateStaticConstructor(ProxyGeneratorClassModel proxyModel)
    {
        return ConstructorDeclaration(proxyModel.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.StaticKeyword)))
            .WithBody(Block(GetStaticConstructorBody()));

        IEnumerable<StatementSyntax> GetStaticConstructorBody()
        {
            if (proxyModel.ShouldGenerateProxyTypeCache)
            {
                yield return GetProxyTypeCacheInitialization();
            }

            foreach (var @interface in proxyModel.Interfaces)
            {
                if (@interface.ShouldGenerateTargetTypeCache)
                {
                    yield return GetTargetTypeCacheInitialization(@interface);
                }

                foreach (var method in @interface.Methods)
                {
                    if (method.Method.ShouldGenerateMethodCache)
                    {
                        yield return GetMethodCacheInitialization(@interface, method);
                    }
                }
            }
        }

        StatementSyntax GetProxyTypeCacheInitialization()
        {
            // ProxyType_Cache = typeof($Name);

            return ExpressionStatement(
                ParseExpression($"{proxyModel.ProxyTypeCacheName} = typeof({proxyModel.Name})"));
        }

        StatementSyntax GetTargetTypeCacheInitialization(ProxyGeneratorInterfaceModel @interface)
        {
            // $TargetTypeCacheName = typeof($InterfaceFullName);
            return ExpressionStatement(
                ParseExpression($"{@interface.TargetTypeCacheName} = typeof({@interface.Type.FullName})"));
        }

        StatementSyntax GetMethodCacheInitialization(
            ProxyGeneratorInterfaceModel @interface,
            ProxyGeneratorInterfaceMethodModel method)
        {
            // $MethodCacheName =
            //      IProxyGeneratorInterface_TargetType_Cache!.GetMethod(
            //          name: MyMethod_0_Name,
            //          bindingAttr: System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,
            //          binder: null,
            //          genericParameterCount: 0,
            //          callConvention: System.Reflection.CallingConventions.Any,
            //          types: new System.Type[]
            //          {
            //              typeof(string),
            //              typeof(int),
            //          },
            //          modifiers: null)!;

            var getMethodCall = InvocationExpression(
                    ParseExpression($"{@interface.TargetTypeCacheName}!.GetMethod"))
                .WithArgumentList(ArgumentList(SeparatedList(GetArgumentList())));

            return ExpressionStatement(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    IdentifierName(method.MethodCacheName),
                    PostfixUnaryExpression(
                        SyntaxKind.SuppressNullableWarningExpression,
                        getMethodCall)));

            IEnumerable<ArgumentSyntax> GetArgumentList()
            {
                // name: MyMethod_0_Name,
                yield return Argument(IdentifierName(method.MethodNameConstName))
                    .WithNameColon(NameColon(IdentifierName("name")));

                // bindingAttr: System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,
                yield return Argument(ParseExpression("System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance"))
                    .WithNameColon(NameColon(IdentifierName("bindingAttr")));

                // binder: null,
                yield return Argument(LiteralExpression(SyntaxKind.NullLiteralExpression))
                    .WithNameColon(NameColon(IdentifierName("binder")));

                // genericParameterCount: 0,
                yield return Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)))
                    .WithNameColon(NameColon(IdentifierName("genericParameterCount")));

                // callConvention: System.Reflection.CallingConventions.Any,
                yield return Argument(ParseExpression("System.Reflection.CallingConventions.Any"))
                    .WithNameColon(NameColon(IdentifierName("callConvention")));

                // types: new System.Type[] {...} -or- types: System.Array.Empty<System.Type>(),
                if (method.Method.Parameters is { Count: > 0 })
                {
                    yield return Argument(
                            ArrayCreationExpression(
                                    ArrayType(ParseTypeName("System.Type"))
                                        .WithRankSpecifiers(SingletonList(
                                            ArrayRankSpecifier(SingletonSeparatedList<ExpressionSyntax>(
                                                OmittedArraySizeExpression())))))
                                .WithInitializer(
                                    InitializerExpression(
                                        SyntaxKind.ArrayInitializerExpression,
                                        SeparatedList(GetTypesExpressions()))))
                        .WithNameColon(NameColon(IdentifierName("types")));
                }
                else
                {
                    yield return Argument(ParseExpression("System.Array.Empty<System.Type>()"))
                        .WithNameColon(NameColon(IdentifierName("types")));
                }

                // modifiers: null,
                yield return Argument(LiteralExpression(SyntaxKind.NullLiteralExpression))
                    .WithNameColon(NameColon(IdentifierName("modifiers")));


                IEnumerable<ExpressionSyntax> GetTypesExpressions()
                {
                    foreach (var parameter in method.Method.Parameters)
                    {
                        var fullName = parameter.Type.FullName;
                        if (fullName.EndsWith("?"))
                        {
                            fullName = fullName.Substring(0, fullName.Length - 1);
                        }
                        yield return ParseExpression($"typeof({fullName})");
                    }
                }
            }
        }
    }

    private static IEnumerable<MemberDeclarationSyntax> GenerateInterfaceImplementation(
        ProxyGeneratorClassModel proxyModel,
        ProxyGeneratorInterfaceModel @interface)
    {
        // private readonly $InterfaceFullName $InterfaceParameterName;
        yield return ParseMemberDeclaration($"private readonly {@interface.Type.FullName} {@interface.ParameterName};")!;

        if (@interface.ShouldGenerateTargetTypeName)
        {
            // private const string $InterfaceName_TargetType_Name = nameof($InterfaceFullName);
            yield return ParseMemberDeclaration($"private const string {@interface.TargetTypeNameName} = nameof({@interface.Type.FullName});")!;
        }

        if (@interface.ShouldGenerateTargetTypeCache)
        {
            // private static readonly System.Type IProxyGeneratorInterface_TargetType_Cache;
            yield return ParseMemberDeclaration($"private static readonly System.Type {@interface.TargetTypeCacheName};")!;
        }

        foreach (var method in @interface.Methods)
        {
            if (method.Method.ShouldGenerateMethodName)
            {
                // private const string $MethodName_$MethodIndex_Name = nameof($InterfaceFullName.$MethodName);
                yield return ParseMemberDeclaration($"private const string {method.MethodNameConstName} = nameof({@interface.Type.FullName}.{method.Method.Name});")!;
            }

            if (method.Method.ShouldGenerateMethodCache)
            {
                // private static readonly System.Reflection.MethodInfo MyMethod_0_Cache;
                yield return ParseMemberDeclaration($"private static readonly System.Reflection.MethodInfo {method.MethodCacheName};")!;
            }

            yield return GenerateInterfaceMethodImplementation(proxyModel, @interface, method);
        }
    }

    // $ReturnType $InterfaceFullName.$MethodName($Parameters) { $Interception }
    private static MemberDeclarationSyntax GenerateInterfaceMethodImplementation(
        ProxyGeneratorClassModel proxyModel,
        ProxyGeneratorInterfaceModel @interface,
        ProxyGeneratorInterfaceMethodModel method)
    {
        var methodDeclaration = MethodDeclaration(
                ParseTypeName(method.Method.ReturnType.FullName),
                Identifier(method.Method.Name))
            .WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifier(
                ParseName(@interface.Type.FullName)))
            .WithParameterList(ParameterList(SeparatedList(GetParameters())))
            .WithBody(Block(GetStatements()));

        if (method.IsAsync)
            methodDeclaration = methodDeclaration
                .WithModifiers(TokenList(Token(SyntaxKind.AsyncKeyword)));

        return methodDeclaration;


        IEnumerable<ParameterSyntax> GetParameters()
        {
            foreach (var parameter in method.Method.Parameters)
            {
                yield return Parameter(Identifier(parameter.Name))
                    .WithType(ParseTypeName(parameter.Type.FullName));
            }
        }

        IEnumerable<StatementSyntax> GetStatements()
        {
            if (proxyModel.Interceptor.BeforeCall is { } beforeCall)
            {
                foreach (var statement in GenerateBeforeCall(beforeCall))
                {
                    yield return statement;
                }
            }

            if (proxyModel.Interceptor.HasAfterCalls)
            {
                // TODO: Use try/catch/finally to implement after-call interceptions
            }
            else
            {
                if (method.ResultType.IsVoid)
                {
                    // [await ]this.$InterfaceParameterName.$MethodName($Parameters);
                    yield return ExpressionStatement(GetOriginalMethodCall());
                }
                else
                {
                    // return [await ]this.$InterfaceParameterName.$MethodName($Parameters);
                    yield return ReturnStatement(GetOriginalMethodCall());
                }
            }
        }

        IEnumerable<StatementSyntax> GenerateBeforeCall(ProxyBeforeCallModel beforeCall)
        {
            // $InterceptorParameterName.BeforeCall(
            //     proxyType: ProxyType_Cache,
            //     proxyTypeName: ProxyType_Name,
            //     proxyInstance: this,
            //     instance: $InterfaceParameterName,
            //     targetType: $InterfaceName_TargetType_Name,
            //     targetTypeName: $InterfaceName_TargetType_Cache,
            //     methodInfo: MyMethod_0_Cache,
            //     methodName: MyMethod_0_Name,
            //     parameters: new object[] { $Parameters });

            if (beforeCall.HasParametersArgument)
            {
                // var parameters = new object[] { $Parameters };
                yield return LocalDeclarationStatement(
                    VariableDeclaration(ParseTypeName("var"))
                        .WithVariables(SingletonSeparatedList(
                            VariableDeclarator(Identifier("parameters"))
                                .WithInitializer(
                                    EqualsValueClause(
                                        ArrayCreationExpression(
                                                ArrayType(ParseTypeName("object?"))
                                                    .WithRankSpecifiers(SingletonList(
                                                        ArrayRankSpecifier(SingletonSeparatedList<ExpressionSyntax>(
                                                            OmittedArraySizeExpression())))))
                                            .WithInitializer(
                                                InitializerExpression(
                                                    SyntaxKind.ArrayInitializerExpression,
                                                    SeparatedList(method.Method.Parameters
                                                        .Select(p => ParseExpression(p.Name))))))))));
            }

            var callExpression = InvocationExpression(
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(proxyModel.Interceptor.ParameterName),
                        IdentifierName(beforeCall.Name)))
                .WithArgumentList(ArgumentList(SeparatedList(
                    GetInterceptorArguments(beforeCall.Parameters))));

            if (proxyModel.Interceptor.HasState)
            {
                yield return LocalDeclarationStatement(
                    VariableDeclaration(ParseTypeName("var"))
                        .WithVariables(SingletonSeparatedList(
                            VariableDeclarator(Identifier("state"))
                                .WithInitializer(
                                    EqualsValueClause(callExpression)))));
            }

            yield return ExpressionStatement(callExpression);
        }

        ExpressionSyntax GetOriginalMethodCall()
        {
            ExpressionSyntax call = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(@interface.ParameterName),
                    IdentifierName(method.Method.Name)))
                .WithArgumentList(ArgumentList(SeparatedList(
                    GetInterceptedArgumentList())));

            if (method.IsAsync)
            {
                call = AwaitExpression(call);
            }

            return call;
        }

        IEnumerable<ArgumentSyntax> GetInterceptedArgumentList()
        {
            // TODO: If parameters could change, take the values from parameters[i] instead
            if (proxyModel.Interceptor.BeforeCall?.ParametersArgument?.InterceptedParameters?.AllowChanges == true)
            {
                for (int i = 0; i < method.Method.Parameters.Count; i++)
                {
                    var parameter = method.Method.Parameters[i];
                    yield return Argument(ParseExpression($"({parameter.Type.FullName})parameters[{i}]"));
                }
            }
            else
            {
                foreach (var parameter in method.Method.Parameters)
                {
                    yield return Argument(IdentifierName(parameter.Name));
                }
            }
        }

        IEnumerable<ArgumentSyntax> GetInterceptorArguments(
            IReadOnlyList<ProxyInterceptorCallParameterModel> parameters)
        {
            foreach (var parameter in parameters)
            {
                yield return Argument(GetParameterValue(parameter))
                    .WithNameColon(NameColon(IdentifierName(parameter.Name)));
            }

            ExpressionSyntax GetParameterValue(ProxyInterceptorCallParameterModel parameter)
            {
                if (parameter.InterceptedProxyType is not null)
                {
                    if (parameter.Type.FullName == "string")
                    {
                        // ProxyType_Name
                        return ParseExpression(@$"{proxyModel.ProxyTypeNameName}");
                    }

                    if (parameter.Type.FullName == typeof(Type).FullName)
                    {
                        // ProxyType_Cache
                        return ParseExpression(@$"{proxyModel.ProxyTypeCacheName}");
                    }
                }

                if (parameter.InterceptedProxyInstance is not null)
                {
                    return ParseExpression("this");
                }

                if (parameter.InterceptedInstance is not null)
                {
                    // $InterfaceParameterName
                    return ParseExpression(@$"{@interface.ParameterName}");
                }

                if (parameter.InterceptedTargetType is not null)
                {
                    if (parameter.Type.FullName == "string")
                    {
                        // $InterfaceName_TargetType_Name
                        return ParseExpression(@$"{@interface.TargetTypeNameName}");
                    }

                    if (parameter.Type.FullName == typeof(Type).FullName)
                    {
                        // $InterfaceName_TargetType_Cache
                        return ParseExpression(@$"{@interface.TargetTypeCacheName}");
                    }
                }

                if (parameter.InterceptedMember is not null)
                {
                    if (parameter.Type.FullName == "System.Reflection.MethodInfo")
                    {
                        // MyMethod_0_Cache
                        return ParseExpression(@$"{method.MethodCacheName}");
                    }

                    if (parameter.Type.FullName == "string")
                    {
                        // MyMethod_0_Name
                        return ParseExpression(@$"{method.MethodNameConstName}");
                    }
                }

                if (parameter.InterceptedParameters is not null)
                {
                    // parameters
                    return ParseExpression("parameters");
                }

                // default!
                return LiteralExpression(SyntaxKind.DefaultLiteralExpression);
            }
        }
    }



    #endregion [ Generate ]

    #endregion [ RegisterProxyClasses ]
}
