using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace MicroCs.Generators.Aop;

internal static class ProxyGeneratorUtils
{
    #region [ Attributes Full Names ]

    private const string GenerateProxyAttributeFullName =
        $"{AopGeneratorUtils.MainNamespace}.GenerateProxyAttribute";

    private const string InterceptorAttributeFullName =
        $"{AopGeneratorUtils.MainNamespace}.InterceptorAttribute";

    #endregion [ Attributes Full Names ]

    #region [ RegisterProxyAttributes ]

    public static void RegisterProxyAttributes(
        this IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(AddAttributesSource);

    private static void AddAttributesSource(
        IncrementalGeneratorPostInitializationContext context)
    {
        var model = new ProxyGeneratorAttributesModel
        {
            Namespace = AopGeneratorUtils.MainNamespace,
        };

        var attributesSource = RenderAttributesSource(model);

        context.AddSource(
            "ProxyGeneratorAttributes.g.cs",
            SourceText.From(attributesSource, Encoding.UTF8));
    }

    private static string RenderAttributesSource(ProxyGeneratorAttributesModel model)
    {
        var builder = new IndentedStringBuilder();

        builder.AppendLine(
            """
            // <auto-generated />

            #nullable enable

            """);
        builder.AppendLine($"namespace {model.Namespace}");
        builder.AppendLine(
            """
            {   // OK
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
                internal sealed class GenerateProxyAttribute : global::System.Attribute
                {
                }
            
                [global::System.AttributeUsage(global::System.AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
                internal sealed class InterceptorAttribute : global::System.Attribute
                {
                }
            }
            """);

        return builder.ToString();
    }

    #endregion [ RegisterProxyAttributes ]

    #region [ RegisterProxyClasses ]

    public static void RegisterProxyClasses(
        this IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                PartialClassWithBaseTypesAndAttributes,
                HasGenerateProxyAttribute)
            .Where(e => e is not null)
            .Select((e, _) => e!);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(classes.Collect()),
            GenerateProxyClasses);
    }

    private static bool PartialClassWithBaseTypesAndAttributes(
        SyntaxNode node,
        CancellationToken cancel)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } @class &&
               @class.Modifiers.Any(SyntaxKind.PartialKeyword) &&
               !@class.Modifiers.Any(SyntaxKind.StaticKeyword) &&
               @class.BaseList?.Types is { Count: > 0 };
    }

    private static ClassDeclarationSyntax? HasGenerateProxyAttribute(
        GeneratorSyntaxContext context,
        CancellationToken cancel)
    {
        if (context.Node is not ClassDeclarationSyntax @class) return null;

        var hasGenerateProxyAttribute = @class
            .HasAttribute(GenerateProxyAttributeFullName, context.SemanticModel);

        return hasGenerateProxyAttribute ? @class : null;
    }

    private static void GenerateProxyClasses(
        SourceProductionContext context,
        (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes) data)
    {
        var models = data.classes.ExtractClassModels(context, data.compilation);

        for (int i = 0; i < models.Count; i++)
        {
            var model = models[i];
            if (!model.ShouldGenerateCode) continue;
            var fileName = $"{model.Name}.{i}.g.cs";
            var tree = GenerateProxyClass(model);
            var source = tree.GetText(Encoding.UTF8);
            context.AddSource(fileName, source);
        }
    }

    #region [ Extract ]

    private static IReadOnlyList<ProxyGeneratorClassModel> ExtractClassModels(
        this ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context,
        Compilation compilation)
    {
        return classes
            .Select(classSyntax => classSyntax.ExtractGeneratorClassModel(context, compilation))
            .Where(model => model is not null)
            .Select(model => model!)
            .ToArray();
    }

    private static ProxyGeneratorClassModel? ExtractGeneratorClassModel(
        this ClassDeclarationSyntax classSyntax,
        SourceProductionContext context,
        Compilation compilation)
    {
        var semanticModel = compilation.GetSemanticModel(classSyntax.SyntaxTree);

        if (semanticModel.GetDeclaredSymbol(classSyntax) is not { } classSymbol)
            return null;

        var className = classSymbol.Name;
        var @namespace = classSymbol.ContainingNamespace?.ToDisplayString();

        var interfaces = classSymbol.AllInterfaces
            .Select(interfaceSymbol => interfaceSymbol.ExtractProxyInterfaceModel(context, compilation))
            .Where(model => model is not null)
            .Select(model => model!)
            .ToArray();

        if (interfaces.Length == 0)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasNoInterfaces,
                    classSyntax.GetLocation(),
                    className));
            return null;
        }

        var interceptor = classSymbol.ExtractInterceptorModel(context, compilation);

        if (interceptor is null) return null;

        return new ProxyGeneratorClassModel
        {
            Namespace = @namespace,
            Name = className,
            Interfaces = interfaces,
            Interceptor = interceptor,
        };
    }

    private static ProxyGeneratorInterfaceModel? ExtractProxyInterfaceModel(
        this INamedTypeSymbol typeSymbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        var type = typeSymbol.ExtractTypeWithMembersModel(context, compilation);

        if (type is null) return null;

        var methods = type.Methods
            .Select((method, index) =>
            {
                var asyncInfo = method.ReturnType.Symbol.GetAsyncInfo(context, compilation);

                return new ProxyGeneratorInterfaceMethodModel
                {
                    Method = method,
                    Index = index,
                    IsAsync = asyncInfo.IsAsync,
                    ResultType = asyncInfo.InnerType ?? method.ReturnType,
                };
            })
            .ToArray();

        return new ProxyGeneratorInterfaceModel
        {
            ParameterName = typeSymbol.Name.ToParameterName(),
            Type = type,
            Methods = methods,
        };
    }

    private static ProxyGeneratorInterceptorModel? ExtractInterceptorModel(
        this INamedTypeSymbol classSymbol,
        SourceProductionContext context,
        Compilation compilation)
    {
        if (!ExtractInterceptorField(classSymbol, context, out var interceptorField)) return null;

        if (interceptorField!.Type is not INamedTypeSymbol interceptorTypeSymbol)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyInterceptorIsNotNamedType,
                    interceptorField.Locations[0],
                    classSymbol.Name));

            return null;
        }

        var interceptorType = interceptorTypeSymbol
            .ExtractTypeWithMembersModel(context, compilation);

        if (interceptorType is null) return null;

        var beforeCall = interceptorType.ExtractBeforeCall(context, compilation);

        return new ProxyGeneratorInterceptorModel
        {
            ParameterName = interceptorField.Name.ToParameterName(),
            Type = interceptorType,
            BeforeCall = beforeCall,
        };
    }

    private static bool ExtractInterceptorField(
        INamedTypeSymbol classSymbol,
        SourceProductionContext context,
        out IFieldSymbol? interceptorField)
    {
        interceptorField = null;
        var interceptorFields = classSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(field => field.HasAttribute(InterceptorAttributeFullName))
            .ToArray();

        if (interceptorFields.Length == 0)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasNoInterceptor,
                    classSymbol.Locations[0],
                    classSymbol.Name));
            return false;
        }

        if (interceptorFields.Length > 1)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AopGeneratorUtils.DiagnosticDescriptors.GeneratedProxyHasMultipleInterceptors,
                    interceptorFields[1].Locations[0],
                    classSymbol.Name));
            return false;
        }

        interceptorField = interceptorFields[0];
        return true;
    }

    private static ProxyBeforeCallModel? ExtractBeforeCall(
        this TypeWithMembersModel type,
        SourceProductionContext context,
        Compilation compilation)
    {
        return null;
        return new ProxyBeforeCallModel()
        {
            Method = type.Methods.First(),
        };
    }

    #endregion [ Extract ]

    #region [ Generate ]

    /// <summary>
    /// Generate proxy class.
    /// Example:
    /// <code>
    /// // <auto-generated />
    ///
    /// #nullable enable
    ///
    /// namespace $Namespace;
    ///
    /// partial class $Name
    /// {
    ///     private static readonly global::System.Type ProxyType_Cache;
    ///
    ///     $InstanceConstructor
    ///
    ///     $StaticConstructor
    ///
    ///     $InterfaceImplementations
    /// }
    /// </summary>
    /// <param name="proxyModel"></param>
    /// <returns></returns>
    private static CompilationUnitSyntax GenerateProxyClass(ProxyGeneratorClassModel proxyModel)
    {
        CompilationUnitSyntax unitSyntax =
            CompilationUnit()
                .WithMembers(SingletonList(GetMainDeclaration()))
                .NormalizeWhitespace();

        return unitSyntax;


        // partial
        // -or-
        // < auto-generated />
        // #nullable enable
        // partial
        SyntaxTokenList GetProxyClassModifiers()
        {
            if (proxyModel.HasNamespace)
                return TokenList(Token(SyntaxKind.PartialKeyword));
            
            return TokenList(Token(
                GeneratorUtils.CreateAutoGeneratedHeaders(),
                SyntaxKind.PartialKeyword,
                TriviaList()));
        }

        // partial class $Name ...
        // -or-
        // namespace $Namespace;
        // partial class $Name ...
        MemberDeclarationSyntax GetMainDeclaration()
        {
            if (proxyModel.HasNamespace)
                return FileScopedNamespaceDeclaration(ParseName(proxyModel.Namespace!))
                    .WithNamespaceKeyword(Token(
                        GeneratorUtils.CreateAutoGeneratedHeaders(),
                        SyntaxKind.NamespaceKeyword,
                        TriviaList()))
                    .WithMembers(SingletonList<MemberDeclarationSyntax>(GetProxyClassDeclaration()));
            
            return GetProxyClassDeclaration();
        }

        // partial class $Name
        // {
        //     $ProxyClassMembers
        // }
        ClassDeclarationSyntax GetProxyClassDeclaration()
        {
            return ClassDeclaration(proxyModel.Name)
                .WithModifiers(GetProxyClassModifiers())
                .WithMembers(List(GetProxyClassMembers()));
        }

        IEnumerable<MemberDeclarationSyntax> GetProxyClassMembers()
        {
            if (proxyModel.ShouldGenerateProxyTypeCache)
            {
                // private static readonly global::System.Type ProxyType_Cache;
                yield return ParseMemberDeclaration($"private static readonly global::System.Type {proxyModel.ProxyTypeCacheName};")!;
            }

            yield return GenerateInstanceConstructor(proxyModel);

            yield return GenerateStaticConstructor(proxyModel);

            foreach (var @interface in proxyModel.Interfaces)
            {
                foreach (var member in GenerateInterfaceImplementation(proxyModel, @interface))
                {
                    yield return member;
                }
            }
        }
    }

    private static MemberDeclarationSyntax GenerateInstanceConstructor(ProxyGeneratorClassModel proxyModel)
    {
        return ConstructorDeclaration(proxyModel.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(ParameterList(SeparatedList(GetInstanceConstructorParameters())))
            .WithBody(Block(GetInstanceConstructorBody()));

        IEnumerable<ParameterSyntax> GetInstanceConstructorParameters()
        {
            foreach (var @interface in proxyModel.Interfaces)
            {
                // $InterfaceFullName $InterfaceParameterName
                yield return Parameter(Identifier(@interface.ParameterName))
                    .WithType(ParseTypeName(@interface.Type.FullName));
            }

            // $InterceptorFullName $InterceptorParameterName
            yield return Parameter(Identifier(proxyModel.Interceptor.ParameterName))
                .WithType(ParseTypeName(proxyModel.Interceptor.Type.FullName));
        }

        IEnumerable<StatementSyntax> GetInstanceConstructorBody()
        {
            foreach (var @interface in proxyModel.Interfaces)
            {
                // this.$InterfaceParameterName = $InterfaceParameterName;
                yield return ExpressionStatement(
                    ParseExpression($"this.{@interface.ParameterName} = {@interface.ParameterName}"));
            }

            // this.$InterceptorParameterName = $InterceptorParameterName;
            yield return ExpressionStatement(
                ParseExpression($"this.{proxyModel.Interceptor.ParameterName} = {proxyModel.Interceptor.ParameterName}"));
        }
    }

    private static MemberDeclarationSyntax GenerateStaticConstructor(ProxyGeneratorClassModel proxyModel)
    {
        return ConstructorDeclaration(proxyModel.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.StaticKeyword)))
            .WithBody(Block(GetStaticConstructorBody()));

        IEnumerable<StatementSyntax> GetStaticConstructorBody()
        {
            if (proxyModel.ShouldGenerateProxyTypeCache)
            {
                yield return GetProxyTypeCacheInitialization();
            }

            foreach (var @interface in proxyModel.Interfaces)
            {
                if (@interface.ShouldGenerateTargetTypeCache)
                {
                    yield return GetTargetTypeCacheInitialization(@interface);
                }

                foreach (var method in @interface.Methods)
                {
                    if (method.Method.ShouldGenerateMethodCache)
                    {
                        yield return GetMethodCacheInitialization(@interface, method);
                    }
                }
            }
        }

        StatementSyntax GetProxyTypeCacheInitialization()
        {
            // ProxyType_Cache = typeof($Name);

            return ExpressionStatement(
                ParseExpression($"{proxyModel.ProxyTypeCacheName} = typeof({proxyModel.Name})"));
        }

        StatementSyntax GetTargetTypeCacheInitialization(ProxyGeneratorInterfaceModel @interface)
        {
            // $TargetTypeCacheName = typeof($InterfaceFullName);
            return ExpressionStatement(
                ParseExpression($"{@interface.TargetTypeCacheName} = typeof({@interface.Type.FullName})"));
        }

        StatementSyntax GetMethodCacheInitialization(
            ProxyGeneratorInterfaceModel @interface,
            ProxyGeneratorInterfaceMethodModel method)
        {
            // $MethodCacheName =
            //      IProxyGeneratorInterface_TargetType_Cache!.GetMethod(
            //          name: MyMethod_0_Name,
            //          bindingAttr: global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance,
            //          binder: null,
            //          genericParameterCount: 0,
            //          callConvention: global::System.Reflection.CallingConventions.Any,
            //          types: new global::System.Type[]
            //          {
            //              typeof(string),
            //              typeof(int),
            //          },
            //          modifiers: null)!;

            var getMethodCall = InvocationExpression(
                    ParseExpression($"{@interface.TargetTypeCacheName}!.GetMethod"))
                .WithArgumentList(ArgumentList(SeparatedList(GetArgumentList())));

            return ExpressionStatement(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    IdentifierName(method.MethodCacheName),
                    PostfixUnaryExpression(
                        SyntaxKind.SuppressNullableWarningExpression,
                        getMethodCall)));

            IEnumerable<ArgumentSyntax> GetArgumentList()
            {
                // name: MyMethod_0_Name,
                yield return Argument(IdentifierName(method.MethodNameConstName))
                    .WithNameColon(NameColon(IdentifierName("name")));

                // bindingAttr: global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance,
                yield return Argument(ParseExpression("global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance"))
                    .WithNameColon(NameColon(IdentifierName("bindingAttr")));

                // binder: null,
                yield return Argument(LiteralExpression(SyntaxKind.NullLiteralExpression))
                    .WithNameColon(NameColon(IdentifierName("binder")));

                // genericParameterCount: 0,
                yield return Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0)))
                    .WithNameColon(NameColon(IdentifierName("genericParameterCount")));

                // callConvention: global::System.Reflection.CallingConventions.Any,
                yield return Argument(ParseExpression("global::System.Reflection.CallingConventions.Any"))
                    .WithNameColon(NameColon(IdentifierName("callConvention")));

                // types: new global::System.Type[] {...} -or- types: global::System.Array.Empty<global::System.Type>(),
                if (method.Method.Parameters is {Count: > 0})
                {
                    yield return Argument(
                            ArrayCreationExpression(
                                    ArrayType(ParseTypeName("global::System.Type"))
                                        .WithRankSpecifiers(SingletonList(
                                            ArrayRankSpecifier(SingletonSeparatedList<ExpressionSyntax>(
                                                OmittedArraySizeExpression())))))
                                .WithInitializer(
                                    InitializerExpression(
                                        SyntaxKind.ArrayInitializerExpression,
                                        SeparatedList(GetTypesExpressions()))))
                        .WithNameColon(NameColon(IdentifierName("types")));
                }
                else
                {
                    yield return Argument(ParseExpression("global::System.Array.Empty<global::System.Type>()"))
                        .WithNameColon(NameColon(IdentifierName("types")));
                }

                // modifiers: null,
                yield return Argument(LiteralExpression(SyntaxKind.NullLiteralExpression))
                    .WithNameColon(NameColon(IdentifierName("modifiers")));


                IEnumerable<ExpressionSyntax> GetTypesExpressions()
                {
                    foreach (var parameter in method.Method.Parameters)
                    {
                        yield return ParseExpression($"typeof({parameter.Type.FullName})");
                    }
                }
            }
        }
    }

    private static IEnumerable<MemberDeclarationSyntax> GenerateInterfaceImplementation(
        ProxyGeneratorClassModel proxyModel,
        ProxyGeneratorInterfaceModel @interface)
    {
        // private readonly $InterfaceFullName $InterfaceParameterName;
        yield return ParseMemberDeclaration($"private readonly {@interface.Type.FullName} {@interface.ParameterName};")!;

        if (@interface.ShouldGenerateTargetTypeCache)
        {
            // private static readonly global::System.Type IProxyGeneratorInterface_TargetType_Cache;
            yield return ParseMemberDeclaration($"private static readonly global::System.Type {@interface.TargetTypeCacheName};")!;
        }
    }

    #endregion [ Generate ]

    #endregion [ RegisterProxyClasses ]
}
